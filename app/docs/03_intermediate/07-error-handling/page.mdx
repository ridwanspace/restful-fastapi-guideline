# Error Handling & Exception Design

## Standardized Error Response Structure

Create consistent error responses across your API:

```python
from fastapi import FastAPI, HTTPException, Request, status
from fastapi.exception_handlers import http_exception_handler
from fastapi.responses import JSONResponse
from pydantic import BaseModel, ValidationError
from typing import List, Optional, Any, Dict
import logging
import traceback
import uuid
from datetime import datetime

class ErrorDetail(BaseModel):
    """Individual error detail"""
    code: str
    message: str
    field: Optional[str] = None
    value: Optional[Any] = None

class APIError(BaseModel):
    """Standardized error response"""
    error: bool = True
    error_code: str
    message: str
    details: List[ErrorDetail] = []
    timestamp: str
    request_id: str
    path: str
    method: str

class CustomHTTPException(HTTPException):
    """Enhanced HTTP exception with additional context"""
    def __init__(
        self,
        status_code: int,
        error_code: str,
        message: str,
        details: List[ErrorDetail] = None,
        headers: dict = None
    ):
        self.error_code = error_code
        self.details = details or []
        super().__init__(status_code=status_code, detail=message, headers=headers)

# Global exception handlers
@app.exception_handler(CustomHTTPException)
async def custom_http_exception_handler(request: Request, exc: CustomHTTPException):
    """Handle custom HTTP exceptions"""
    
    request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))
    
    error_response = APIError(
        error_code=exc.error_code,
        message=exc.detail,
        details=exc.details,
        timestamp=datetime.utcnow().isoformat() + "Z",
        request_id=request_id,
        path=str(request.url.path),
        method=request.method
    )
    
    # Log error for monitoring
    logging.error(f"API Error: {exc.error_code} - {exc.detail}", extra={
        "request_id": request_id,
        "path": request.url.path,
        "method": request.method,
        "status_code": exc.status_code
    })
    
    return JSONResponse(
        status_code=exc.status_code,
        content=error_response.dict(),
        headers=exc.headers
    )

@app.exception_handler(ValidationError)
async def validation_exception_handler(request: Request, exc: ValidationError):
    """Handle Pydantic validation errors"""
    
    request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))
    
    details = []
    for error in exc.errors():
        field_path = ".".join(str(loc) for loc in error["loc"])
        details.append(ErrorDetail(
            code="VALIDATION_ERROR",
            message=error["msg"],
            field=field_path,
            value=error.get("input")
        ))
    
    error_response = APIError(
        error_code="VALIDATION_FAILED",
        message="Request validation failed",
        details=details,
        timestamp=datetime.utcnow().isoformat() + "Z",
        request_id=request_id,
        path=str(request.url.path),
        method=request.method
    )
    
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content=error_response.dict()
    )

@app.exception_handler(500)
async def internal_server_error_handler(request: Request, exc: Exception):
    """Handle unexpected server errors"""
    
    request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))
    error_id = str(uuid.uuid4())
    
    # Log full traceback for debugging
    logging.error(f"Internal Server Error: {error_id}", extra={
        "request_id": request_id,
        "error_id": error_id,
        "traceback": traceback.format_exc(),
        "path": request.url.path,
        "method": request.method
    })
    
    error_response = APIError(
        error_code="INTERNAL_SERVER_ERROR",
        message="An unexpected error occurred",
        details=[ErrorDetail(
            code="SYSTEM_ERROR",
            message=f"Error ID: {error_id} - Please contact support"
        )],
        timestamp=datetime.utcnow().isoformat() + "Z",
        request_id=request_id,
        path=str(request.url.path),
        method=request.method
    )
    
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content=error_response.dict()
    )

# Business logic error examples
class UserNotFoundError(CustomHTTPException):
    def __init__(self, user_id: int):
        super().__init__(
            status_code=status.HTTP_404_NOT_FOUND,
            error_code="USER_NOT_FOUND",
            message=f"User with ID {user_id} not found",
            details=[ErrorDetail(
                code="RESOURCE_NOT_FOUND",
                message="The requested user does not exist",
                field="user_id",
                value=user_id
            )]
        )

class DuplicateEmailError(CustomHTTPException):
    def __init__(self, email: str):
        super().__init__(
            status_code=status.HTTP_409_CONFLICT,
            error_code="DUPLICATE_EMAIL",
            message="Email address already exists",
            details=[ErrorDetail(
                code="UNIQUE_CONSTRAINT_VIOLATION",
                message="This email address is already registered",
                field="email",
                value=email
            )]
        )

class InsufficientPermissionsError(CustomHTTPException):
    def __init__(self, required_permission: str):
        super().__init__(
            status_code=status.HTTP_403_FORBIDDEN,
            error_code="INSUFFICIENT_PERMISSIONS",
            message="Access denied",
            details=[ErrorDetail(
                code="PERMISSION_REQUIRED",
                message=f"Required permission: {required_permission}",
                field="permission",
                value=required_permission
            )]
        )

# Usage examples
@app.get("/users/{user_id}")
async def get_user_with_errors(user_id: int):
    """Example endpoint demonstrating error handling"""
    
    if user_id == 999:
        raise UserNotFoundError(user_id)
    
    if user_id < 0:
        raise CustomHTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            error_code="INVALID_USER_ID",
            message="User ID must be positive",
            details=[ErrorDetail(
                code="INVALID_VALUE",
                message="User ID cannot be negative",
                field="user_id",
                value=user_id
            )]
        )
    
    return {"id": user_id, "name": f"User {user_id}"}

@app.post("/users")
async def create_user_with_errors(user_data: dict):
    """Example demonstrating business logic errors"""
    
    email = user_data.get("email")
    if email == "duplicate@example.com":
        raise DuplicateEmailError(email)
    
    return {"id": 123, "email": email, "message": "User created"}
```

## Error Classification and Handling Strategy

Implement different handling strategies for different error types:

```python
from enum import Enum
from typing import Type
import asyncio

class ErrorCategory(Enum):
    VALIDATION = "validation"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    BUSINESS_LOGIC = "business_logic"
    SYSTEM = "system"
    EXTERNAL_SERVICE = "external_service"

class BaseAPIError(Exception):
    """Base class for all API errors"""
    category: ErrorCategory
    error_code: str
    message: str
    retryable: bool = False
    
    def __init__(self, message: str, details: List[ErrorDetail] = None):
        self.message = message
        self.details = details or []
        super().__init__(message)

class ValidationError(BaseAPIError):
    category = ErrorCategory.VALIDATION
    error_code = "VALIDATION_ERROR"
    status_code = status.HTTP_422_UNPROCESSABLE_ENTITY

class AuthenticationError(BaseAPIError):
    category = ErrorCategory.AUTHENTICATION
    error_code = "AUTHENTICATION_ERROR"
    status_code = status.HTTP_401_UNAUTHORIZED

class AuthorizationError(BaseAPIError):
    category = ErrorCategory.AUTHORIZATION
    error_code = "AUTHORIZATION_ERROR"
    status_code = status.HTTP_403_FORBIDDEN

class BusinessLogicError(BaseAPIError):
    category = ErrorCategory.BUSINESS_LOGIC
    status_code = status.HTTP_409_CONFLICT

class SystemError(BaseAPIError):
    category = ErrorCategory.SYSTEM
    error_code = "SYSTEM_ERROR"
    status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
    retryable = True

class ExternalServiceError(BaseAPIError):
    category = ErrorCategory.EXTERNAL_SERVICE
    error_code = "EXTERNAL_SERVICE_ERROR"
    status_code = status.HTTP_502_BAD_GATEWAY
    retryable = True

# Error handling with retry logic
async def handle_external_service_call(service_name: str, operation: callable, max_retries: int = 3):
    """Handle external service calls with retry logic"""
    
    for attempt in range(max_retries):
        try:
            return await operation()
        except Exception as e:
            if attempt == max_retries - 1:
                raise ExternalServiceError(
                    f"Failed to communicate with {service_name} after {max_retries} attempts",
                    details=[ErrorDetail(
                        code="SERVICE_UNAVAILABLE",
                        message=f"Service {service_name} is currently unavailable",
                        value=str(e)
                    )]
                )
            
            # Exponential backoff
            await asyncio.sleep(2 ** attempt)

# Circuit breaker pattern for external services
class CircuitBreaker:
    def __init__(self, failure_threshold: int = 5, timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
    
    async def call(self, operation: callable):
        if self.state == "OPEN":
            if datetime.utcnow().timestamp() - self.last_failure_time > self.timeout:
                self.state = "HALF_OPEN"
            else:
                raise ExternalServiceError("Circuit breaker is OPEN")
        
        try:
            result = await operation()
            if self.state == "HALF_OPEN":
                self.state = "CLOSED"
                self.failure_count = 0
            return result
        except Exception as e:
            self.failure_count += 1
            self.last_failure_time = datetime.utcnow().timestamp()
            
            if self.failure_count >= self.failure_threshold:
                self.state = "OPEN"
            
            raise e
```