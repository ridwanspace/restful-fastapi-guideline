# 🔐 Authentication and Authorization with FastAPI

*Building a fortress-level security system for your API kingdom*

## 🏰 The Security Kingdom Analogy

Imagine your FastAPI application as a medieval kingdom with multiple layers of security:

- **🏰 Castle Gates (Authentication)**: Guards check who you are before letting you in
- **🗝️ Royal Keys (Authorization)**: Different keys unlock different parts of the castle
- **⏰ Time-Limited Passes (JWT Tokens)**: Your visitor pass expires and needs renewal
- **👑 Noble Ranks (Roles)**: Kings, knights, and citizens have different access levels
- **📜 Royal Decrees (Permissions)**: Specific rights to read scrolls, write laws, or access treasure

Just like a well-defended kingdom, your API needs multiple security layers working together to protect valuable resources from unauthorized access.

## 🎓 What You'll Master

By the end of this guide, you'll have built a complete security system that rivals enterprise-grade applications. Here's your learning journey:

### 🗺️ Your Security Journey Map

```mermaid
graph TB
    subgraph "🏰 Kingdom Entry (Authentication)"
        A1[Visitor Arrives<br/>👤 User Registration] --> A2[Show Credentials<br/>🔑 Login Process]
        A2 --> A3[Guard Verification<br/>✅ Password Check]
        A3 --> A4[Issue Royal Pass<br/>🎫 JWT Token]
    end
    
    subgraph "🗝️ Palace Navigation (Authorization)"
        A4 --> B1[Present Pass<br/>📋 Token Validation]
        B1 --> B2[Check Noble Rank<br/>👑 Role Verification]
        B2 --> B3[Verify Royal Decree<br/>📜 Permission Check]
        B3 --> B4[Grant/Deny Access<br/>🚪 Resource Access]
    end
    
    subgraph "🛡️ Kingdom Security"
        C1[Password Encryption<br/>🔐 Bcrypt Hashing]
        C2[Pass Expiration<br/>⏰ Token Timeout]
        C3[Attack Prevention<br/>🛡️ Rate Limiting]
        C4[Royal Guards<br/>👮‍♂️ Security Middleware]
    end
    
    A3 -.-> C1
    A4 -.-> C2
    A2 -.-> C3
    B1 -.-> C4
    
    style A1 fill:#e3f2fd,color:#3b3b3b
    style A4 fill:#f3e5f5,color:#3b3b3b
    style B4 fill:#e8f5e8,color:#3b3b3b
    style C1 fill:#fff3e0,color:#3b3b3b
```

### 🔑 **Authentication Arsenal**
*Kingdom Analogy: Different types of royal identification methods*

| Method | Kingdom Parallel | Best For | Security Level |
|---------|------------------|----------|----------------|
| **JWT Tokens** | 🎫 Magical passes with built-in expiration | Modern web apps | ⭐⭐⭐⭐⭐ |
| **Session Cookies** | 🍪 Royal dining hall tokens | Traditional websites | ⭐⭐⭐⭐ |
| **API Keys** | 🗝️ Master keys for trusted allies | Service-to-service | ⭐⭐⭐ |
| **OAuth2** | 🤝 Alliance treaties with other kingdoms | Third-party login | ⭐⭐⭐⭐⭐ |

💡 **Tip**: Start with JWT tokens - they're like self-contained royal scrolls that carry all the information needed to verify someone's identity without asking the castle's record keeper every time!

### 🛡️ **Authorization Strategies**
*Kingdom Analogy: Different ways to control access within the palace*

#### 📊 Access Control Pyramid
```mermaid
graph TD
    A[👑 King/Admin<br/>Can do everything] --> B[🏰 Noble/Manager<br/>Department access]
    B --> C[⚔️ Knight/User<br/>Specific permissions]
    C --> D[🧑‍🌾 Peasant/Guest<br/>Read-only access]
    
    style A fill:#ffd700,color:#3b3b3b
    style B fill:#c0c0c0,color:#3b3b3b
    style C fill:#cd7f32,color:#3b3b3b
    style D fill:#ddd,color:#3b3b3b
```

- **🎭 Role-Based (RBAC)**: Like noble titles - each rank has predefined privileges
- **📜 Permission-Based**: Like specific royal decrees - granular control over actions
- **🏺 Resource-Level**: Like personal treasure chests - ownership-based access
- **🧠 Dynamic Authorization**: Like context-aware guards who consider time, location, and circumstances

### 🔒 **Security Fortress Features**
*Kingdom Analogy: Castle defenses and security protocols*

#### 🏰 Defense Layers
```mermaid
graph LR
    A[🌊 Moat<br/>Rate Limiting] --> B[🚪 Gate<br/>Authentication]
    B --> C[🗝️ Keys<br/>Authorization]
    C --> D[👮‍♂️ Guards<br/>Middleware]
    D --> E[💎 Treasure<br/>Protected Resources]
    
    style A fill:#87ceeb,color:#3b3b3b
    style E fill:#ffd700,color:#3b3b3b
```

- **🔐 Password Fortress**: Bcrypt encryption stronger than castle walls
- **⏰ Time-Sensitive Passes**: Automatic token expiration prevents stolen passes
- **🛡️ Anti-Siege Measures**: Rate limiting stops battering ram attacks
- **🚨 Royal Guards**: Security headers patrol every response

## 🏗️ Building Your Security Kingdom

### 🎯 The Royal Architecture Blueprint

Think of this as designing a complete medieval castle with modern security features. We'll build it layer by layer, just like constructing a fortress that can withstand any siege!

```mermaid
graph TB
    subgraph "🏰 Castle Gates (Authentication Layer)"
        A1[🛡️ Royal Guard Station<br/>Password Authentication]
        A2[🎫 Pass Issuer<br/>JWT Token Generation]
        A3[📋 Pass Inspector<br/>Token Validation]
        A4[⏰ Time Keeper<br/>Session Management]
    end
    
    subgraph "🗝️ Palace Access (Authorization Layer)"
        B1[👑 Rank Checker<br/>Role Verification]
        B2[📜 Decree Reader<br/>Permission Checking]
        B3[🏺 Treasure Guardian<br/>Resource Access Control]
        B4[🧠 Wise Advisor<br/>Dynamic Rules Engine]
    end
    
    subgraph "🛡️ Kingdom Defenses (Security Features)"
        C1[🔐 Royal Vault<br/>Password Hashing]
        C2[⏳ Sand Timer<br/>Token Expiration]
        C3[🌊 Castle Moat<br/>Rate Limiting]
        C4[📚 Royal Chronicle<br/>Audit Logging]
    end
    
    A1 --> A2
    A2 --> A3
    A3 --> B1
    B1 --> B2
    B2 --> B3
    B3 --> B4
    
    A1 -.-> C1
    A2 -.-> C2
    A1 -.-> C3
    B3 -.-> C4
    
    style A1 fill:#e3f2fd,color:#3b3b3b
    style B1 fill:#f3e5f5,color:#3b3b3b
    style C1 fill:#fff3e0,color:#3b3b3b
    style B4 fill:#e8f5e8,color:#3b3b3b
```

### 🎓 Progressive Learning Path

**📍 Where We're Going**: From basic password checking to enterprise-grade security fortress

| Step | Kingdom Building Phase | What You'll Learn | Time Needed |
|------|------------------------|-------------------|-------------|
| **1** | 🏗️ Foundation Laying | Dependencies & Models | 15 min |
| **2** | 🔐 Vault Construction | Password Security | 20 min |
| **3** | 🎫 Pass System Design | JWT Token Management | 25 min |
| **4** | 👤 Guard Training | User Authentication | 20 min |
| **5** | 🗝️ Key Distribution | Authorization Patterns | 30 min |
| **6** | 🚪 Gate Installation | Protected Endpoints | 25 min |
| **7** | 🛡️ Defense Systems | Security Middleware | 20 min |
| **8** | 🎯 Kingdom Testing | Complete Integration | 15 min |

💡 **Learning Tip**: Each step builds on the previous one, like constructing a castle floor by floor. Don't skip ahead - each foundation stone matters!

### 🔐 Step 1: Foundation Laying (Dependencies & Configuration)

**Kingdom Analogy**: Setting up the royal armory and establishing the kingdom's security protocols

#### 🏗️ The Royal Toolbox

**What we're building**: The foundational tools and magical artifacts needed to secure our kingdom

```python
# 🏰 Import the Royal Security Arsenal
from fastapi import FastAPI, Depends, HTTPException, status, Security
from fastapi.security import (
    HTTPBearer,              # 🛡️ Bearer token guard (for JWT passes)
    HTTPAuthorizationCredentials,  # 📋 Credential verification papers
    APIKeyHeader,            # 🗝️ Master key system for trusted allies
    OAuth2PasswordBearer,    # 🤝 Alliance treaty handler (OAuth2)
    OAuth2PasswordRequestForm  # 📝 Login request scroll
)
from pydantic import BaseModel, EmailStr  # 📜 Royal decree templates (data models)
from passlib.context import CryptContext  # 🔐 Royal vault (password encryption)
from jose import JWTError, jwt            # 🎫 Magical pass creation & validation
from datetime import datetime, timedelta  # ⏰ Time management for pass expiration
from typing import Optional, List, Dict, Any  # 📝 Type hints for clarity
import secrets  # 🎲 Random number generation for ultimate security
import os      # 🌍 Environment variable access for secrets

# 🏰 Royal Security Configuration (The Kingdom's Laws)
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-change-in-production")
# ⚠️ WARNING: Never use the default key in production! It's like leaving castle gates unlocked!

ALGORITHM = "HS256"  # 🔒 The royal encryption method for magical passes
ACCESS_TOKEN_EXPIRE_MINUTES = 30  # ⏰ Short passes expire quickly (like day visitors)
REFRESH_TOKEN_EXPIRE_DAYS = 7     # 🗓️ Long-term passes for trusted allies

# 🛡️ Security Schemes (Different types of guard posts)
bearer_scheme = HTTPBearer()  # 🎫 Main gate guard for JWT passes
api_key_scheme = APIKeyHeader(name="X-API-Key")  # 🗝️ Master key checkpoint
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/token")  # 🤝 Alliance gate

# 🔐 Royal Vault Configuration (Password fortress)
pwd_context = CryptContext(
    schemes=["bcrypt"],      # 🏰 Use the strongest castle walls (bcrypt)
    deprecated="auto"        # 🔄 Automatically upgrade old security measures
)
```

### ✅ What Just Happened?

We've established our kingdom's security infrastructure:
- **🏰 Security Arsenal**: Imported all tools needed for authentication
- **📜 Royal Laws**: Set configuration constants for token lifetimes
- **🛡️ Guard Posts**: Created different security schemes for various access types
- **🔐 Royal Vault**: Set up bcrypt for unbreakable password encryption

### 🔧 Production Security Notes

💡 **Secret Key Management**: 
```bash
# Generate a secure secret key (run this once)
python -c "import secrets; print(secrets.token_urlsafe(32))"
```

⚠️ **Environment Variables**:
```bash
# Set in your production environment
export SECRET_KEY="your-super-secure-generated-key-here"
export DATABASE_URL="your-database-connection-string"
```

#### 📜 Royal Identity Scrolls (Data Models)

**Kingdom Analogy**: Creating official documents that define citizens, visitors, and royal passes

**What we're building**: The official templates for all identity documents in our kingdom

```python
# 👤 Royal Citizen Record (Complete user profile)
class User(BaseModel):
    """
    The official royal registry entry for each kingdom citizen.
    Like a complete dossier kept in the royal archives.
    """
    id: int                              # 🆔 Unique citizen number
    username: str                        # 🏷️ Public name (like a royal title)
    email: EmailStr                      # 📧 Royal messenger address
    full_name: Optional[str] = None      # 👑 Full ceremonial name
    roles: List[str] = []               # 🎭 Noble ranks (admin, user, guest)
    permissions: List[str] = []         # 📜 Specific royal decrees granted
    is_active: bool = True              # ✅ Still welcome in the kingdom
    is_verified: bool = False           # 🔐 Has proven identity via royal seal

# 📝 New Citizen Application (Registration form)
class UserCreate(BaseModel):
    """
    Application scroll for new citizens seeking kingdom entry.
    Like filling out immigration papers.
    """
    username: str          # 🏷️ Desired public name
    email: EmailStr        # 📧 Messenger contact
    password: str          # 🔑 Secret passphrase for identity
    full_name: Optional[str] = None  # 👑 Full ceremonial name

# 🚪 Gate Entry Request (Login credentials)
class UserLogin(BaseModel):
    """
    Simple credentials presented at the kingdom gates.
    Like showing ID and stating your business.
    """
    username: str    # 🏷️ Who you claim to be
    password: str    # 🔑 Secret proof of identity

# 🎫 Royal Pass Package (Complete token response)
class Token(BaseModel):
    """
    The complete set of magical passes issued to authenticated citizens.
    Like getting both a day pass and a long-term resident card.
    """
    access_token: str              # 🎫 Short-term magical pass (30 minutes)
    refresh_token: str             # 🎟️ Long-term renewal ticket (7 days)
    token_type: str = "bearer"     # 🛡️ Type of pass (always "bearer")
    expires_in: int               # ⏰ Seconds until day pass expires

# 📋 Pass Content Decoder (Token payload data)
class TokenData(BaseModel):
    """
    The information extracted from a magical pass when inspected.
    Like reading the details written on a royal document.
    """
    user_id: Optional[int] = None    # 🆔 Citizen identification number
    username: Optional[str] = None   # 🏷️ Public name on the pass
    roles: List[str] = []           # 🎭 Noble ranks written on pass
    permissions: List[str] = []     # 📜 Specific rights granted by pass
```

### ✅ Understanding the Royal Documents

Here's how these models work together in our kingdom:

```mermaid
graph LR
    A[👤 New Visitor<br/>UserCreate] --> B[🏰 Registration Gate]
    B --> C[👑 Full Citizen<br/>User Model]
    C --> D[🚪 Login Gate<br/>UserLogin]
    D --> E[🎫 Royal Passes<br/>Token Package]
    E --> F[📋 Pass Inspector<br/>TokenData]
    
    style A fill:#e3f2fd,color:#3b3b3b
    style C fill:#f3e5f5,color:#3b3b3b
    style E fill:#e8f5e8,color:#3b3b3b
```

### 🎓 Model Usage Examples

**Registration Process**:
```python
# A new visitor wants to join the kingdom
new_citizen = UserCreate(
    username="brave_knight",
    email="knight@kingdom.com", 
    password="SecurePass123!",
    full_name="Sir Brave Knight"
)
```

**Login Process**:
```python
# Existing citizen requests entry
gate_request = UserLogin(
    username="brave_knight",
    password="SecurePass123!"
)
```

**Token Response**:
```python
# Kingdom issues magical passes
royal_passes = Token(
    access_token="eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
    refresh_token="eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
    expires_in=1800  # 30 minutes
)
```

### 🔒 Step 2: Royal Vault Construction (Password Security)

**Kingdom Analogy**: Building an impenetrable vault to protect citizens' secret passphrases

#### 🏛️ The Royal Cryptography Workshop

**What we're building**: Magical spells that transform weak secrets into unbreakable fortress walls

Think of password hashing like a royal alchemist who transforms ordinary metals into indestructible gold. Once transformed, even the alchemist can't reverse the process - but they can verify if new metal matches the gold they created!

```python
import re  # 🔍 Royal pattern inspector for password validation

# 🔐 The Royal Vault Master (Password verification)
def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Compare a citizen's claimed secret against the royal vault record.
    
    Kingdom Analogy: Like a royal guard comparing a visitor's stated password
    against the encrypted version stored in the castle's secure archives.
    The guard never sees the original password, only the magical transformation.
    
    Args:
        plain_password: The secret the citizen claims to know
        hashed_password: The encrypted version from our royal vault
        
    Returns:
        True if secrets match, False if impostor detected
    """
    return pwd_context.verify(plain_password, hashed_password)

# 🏰 The Royal Alchemist (Password encryption)
def get_password_hash(password: str) -> str:
    """
    Transform a citizen's secret into unbreakable vault storage.
    
    Kingdom Analogy: Like a royal alchemist using magical salt and fire
    to transform ordinary metal into unique, unbreakable gold bars.
    Each transformation is unique - even identical passwords become
    different vault entries!
    
    Args:
        password: The citizen's chosen secret passphrase
        
    Returns:
        A magical hash that can never be reversed to reveal the original
    """
    return pwd_context.hash(password)

# 🗡️ The Royal Standards Inspector (Password strength validation)
def validate_password_strength(password: str) -> bool:
    """
    Ensure citizen secrets meet royal security standards.
    
    Kingdom Analogy: Like royal standards for sword quality - each blade
    must meet specific requirements for length, strength, and design
    to be worthy of kingdom defense.
    
    Royal Password Decree:
    - Minimum 8 characters (like a sword must be long enough)
    - Mix of upper and lower case (varied steel tempering)
    - Contains numbers (precision craftsmanship marks)
    - Special characters (unique engravings for authenticity)
    
    Args:
        password: The proposed secret to inspect
        
    Returns:
        True if meets royal standards
        
    Raises:
        HTTPException: If password fails any royal decree
    """
    
    # 📏 Length Inspection (Sword length requirement)
    if len(password) < 8:
        raise HTTPException(
            status_code=400,
            detail="🗡️ Password too short! Royal decree requires at least 8 characters (like a sword must be long enough for battle)"
        )
    
    # 🔠 Uppercase Inspection (Strong steel tempering)
    if not re.search(r"[A-Z]", password):
        raise HTTPException(
            status_code=400,
            detail="⚔️ Missing uppercase letters! Add some royal capitals (like strong steel in your sword)"
        )
    
    # 🔡 Lowercase Inspection (Flexible steel tempering)
    if not re.search(r"[a-z]", password):
        raise HTTPException(
            status_code=400,
            detail="🗡️ Missing lowercase letters! Add some common letters (like flexible steel in your sword)"
        )
    
    # 🔢 Number Inspection (Precision craftsmanship marks)
    if not re.search(r"\d", password):
        raise HTTPException(
            status_code=400,
            detail="🔢 Missing numbers! Add some digits (like precision marks on royal weapons)"
        )
    
    # ⚡ Special Character Inspection (Unique engravings)
    if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
        raise HTTPException(
            status_code=400,
            detail="✨ Missing special characters! Add symbols like !@#$% (like unique engravings that prove authenticity)"
        )
    
    # 🎉 Password meets all royal standards!
    return True
```

### ✅ How the Royal Vault Works

Here's the magical transformation process:

```mermaid
graph LR
    A[🔑 Plain Password<br/>'MySecret123!'] --> B[🧙‍♂️ Royal Alchemist<br/>bcrypt + salt]
    B --> C[🔐 Vault Storage<br/>'$2b$12$...']
    
    D[🚪 Login Attempt<br/>'MySecret123!'] --> E[🔍 Royal Verification]
    E --> C
    E --> F{Match?}
    F -->|Yes| G[✅ Access Granted]
    F -->|No| H[❌ Impostor Detected]
    
    style A fill:#e3f2fd,color:#3b3b3b
    style C fill:#fff3e0,color:#3b3b3b
    style G fill:#e8f5e8,color:#3b3b3b
    style H fill:#ffebee,color:#3b3b3b
```

### 🎓 Password Security Levels

| Security Level | Kingdom Analogy | Example | Strength |
|----------------|-----------------|---------|----------|
| **Weak** 🗡️ | Wooden training sword | `password` | ⭐ |
| **Fair** ⚔️ | Basic iron blade | `Password1` | ⭐⭐ |
| **Good** 🛡️ | Quality steel sword | `MyPass123!` | ⭐⭐⭐ |
| **Strong** 👑 | Royal enchanted blade | `Kn1ght$0fth3R0undT@bl3` | ⭐⭐⭐⭐⭐ |

### 💡 Royal Security Tips

**🔐 Password Best Practices**:
- Use passphrases: `Dragon$Fly2Castle!` (tells a story)
- Mix languages: `Hola123World!` (confuses attackers)
- Personal systems: `MyDog+2023+Birthday!` (memorable but complex)

**⚠️ Never Do This**:
- Store plain passwords (like leaving treasure unguarded)
- Use weak default passwords (like using wooden gates)
- Reuse the same password everywhere (like having one key for everything)

### 🎫 Step 3: Magical Pass System Design (JWT Token Management)

**Kingdom Analogy**: Creating self-authenticating magical scrolls that prove identity without needing to check with the castle

#### 🧙‍♂️ The Royal Scroll Enchanter's Workshop

**What we're building**: Magical passes that contain all the information guards need, enchanted so they can't be forged

Think of JWT tokens like magical scrolls that shimmer with authenticity. Each scroll contains the bearer's identity, permissions, and an expiration time - all sealed with royal magic that can't be faked!

```python
# 🎫 The Royal Pass Creator (Access token generation)
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """
    Forge a magical short-term pass for kingdom access.
    
    Kingdom Analogy: Like a royal enchanter creating a day pass that glows
    with authentic magic. The pass contains the visitor's identity and permissions,
    sealed with royal enchantments that expire after a short time.
    
    Args:
        data: Citizen information to encode in the magical scroll
        expires_delta: How long before the magic fades (default: 15 minutes)
        
    Returns:
        A magical JWT string that proves identity and permissions
    """
    # 📜 Prepare the scroll content (copy data to avoid mutations)
    scroll_content = data.copy()
    
    # ⏰ Set the magical expiration time
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)  # Quick expiry for security
    
    # ✨ Add royal authentication magic
    scroll_content.update({
        "exp": expire,        # ⏰ When the magic fades
        "type": "access",     # 🎫 Type of magical pass
        "iat": datetime.utcnow()  # 🕐 When the magic was cast
    })
    
    # 🔮 Enchant the scroll with royal seal
    magical_scroll = jwt.encode(scroll_content, SECRET_KEY, algorithm=ALGORITHM)
    return magical_scroll

# 🎟️ The Royal Renewal Token Creator (Refresh token generation)
def create_refresh_token(data: dict) -> str:
    """
    Create a long-term renewal scroll for trusted citizens.
    
    Kingdom Analogy: Like issuing a special renewal ticket that allows
    trusted citizens to get new day passes without going through
    the full identity verification process again.
    
    Args:
        data: Basic citizen information for renewal purposes
        
    Returns:
        A long-lasting JWT refresh token
    """
    # 📜 Prepare renewal scroll (minimal information needed)
    renewal_content = data.copy()
    
    # ⏰ Set long expiration for renewal token
    expire = datetime.utcnow() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    
    # ✨ Add renewal-specific magic
    renewal_content.update({
        "exp": expire,
        "type": "refresh",  # 🎟️ Special renewal token type
        "iat": datetime.utcnow()
    })
    
    # 🔮 Enchant with long-term royal seal
    renewal_scroll = jwt.encode(renewal_content, SECRET_KEY, algorithm=ALGORITHM)
    return renewal_scroll

# 🔍 The Royal Scroll Inspector (Token verification)
def verify_token(token: str, token_type: str = "access") -> TokenData:
    """
    Inspect a magical scroll to verify authenticity and extract information.
    
    Kingdom Analogy: Like a royal guard examining a visitor's magical pass
    to verify it's authentic and hasn't expired. The guard can read all
    the enchanted information without needing to contact the castle.
    
    Args:
        token: The magical scroll to inspect
        token_type: Expected type of magic ("access" or "refresh")
        
    Returns:
        TokenData containing all the citizen information from the scroll
        
    Raises:
        HTTPException: If the scroll is forged, expired, or wrong type
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="🚫 Magical scroll inspection failed - could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        # 🔮 Attempt to read the magical scroll
        scroll_content = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        
        # 🎫 Verify this is the correct type of magical pass
        if scroll_content.get("type") != token_type:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"🎭 Wrong type of magical pass! Expected {token_type}, got {scroll_content.get('type')}"
            )
        
        # 📋 Extract citizen information from the scroll
        user_id: int = scroll_content.get("user_id")
        username: str = scroll_content.get("sub")  # "sub" is JWT standard for subject
        roles: List[str] = scroll_content.get("roles", [])
        permissions: List[str] = scroll_content.get("permissions", [])
        
        # 🚨 Verify essential information is present
        if username is None or user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="🧾 Magical scroll is incomplete - missing citizen identification"
            )
        
        # 📊 Return the decoded citizen information
        return TokenData(
            user_id=user_id,
            username=username,
            roles=roles,
            permissions=permissions
        )
        
    except JWTError as enchantment_error:
        # 🚫 The magical scroll failed inspection (expired, forged, or corrupted)
        raise credentials_exception
```

### ✅ How Magical Scrolls Work

Here's the complete enchantment and verification process:

```mermaid
sequenceDiagram
    participant Citizen
    participant Guard as 🛡️ Royal Guard
    participant Enchanter as 🧙‍♂️ Royal Enchanter
    participant Vault as 🔐 Royal Vault
    
    Note over Citizen, Vault: Magical Scroll Creation
    Citizen->>Guard: Present credentials
    Guard->>Vault: Verify identity
    Vault-->>Guard: Identity confirmed
    Guard->>Enchanter: Request magical scroll
    Enchanter->>Enchanter: Encode citizen info + expiration
    Enchanter->>Enchanter: Apply royal seal (SECRET_KEY)
    Enchanter-->>Guard: Return magical scroll
    Guard-->>Citizen: Issue magical pass
    
    Note over Citizen, Vault: Scroll Verification Later
    Citizen->>Guard: Present magical scroll
    Guard->>Guard: Decode with royal seal
    Guard->>Guard: Check expiration & type
    Guard->>Guard: Extract citizen info
    Guard-->>Citizen: Grant/deny access
```

### 🎭 Token Types & Their Purposes

| Token Type | Kingdom Analogy | Lifetime | Purpose | Security Level |
|------------|-----------------|----------|---------|----------------|
| **Access Token** 🎫 | Day visitor pass | 30 minutes | Resource access | ⭐⭐⭐⭐⭐ |
| **Refresh Token** 🎟️ | Renewal ticket | 7 days | Get new access tokens | ⭐⭐⭐⭐ |

### 🔍 JWT Anatomy Breakdown

A JWT token has three parts, like a three-part royal scroll:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJicmF2ZV9rbmlnaHQiLCJ1c2VyX2lkIjoxLCJyb2xlcyI6WyJ1c2VyIl0sImV4cCI6MTY5NzI4MDAwMH0.signature_hash_here
         ↑ Header              ↑ Payload                                                                           ↑ Signature
    🏷️ Scroll Type         📜 Citizen Information                                                              🔐 Royal Seal
```

**🏷️ Header**: Declares "This is a JWT with HS256 encryption"
**📜 Payload**: Contains all citizen information (ID, roles, expiration)
**🔐 Signature**: Royal seal that proves authenticity

### 💡 Token Security Best Practices

**🎫 Access Token Rules**:
- Keep short-lived (30 minutes max) - like day passes that expire quickly
- Store in memory only - never in localStorage permanently  
- Include minimal necessary information

**🎟️ Refresh Token Rules**:
- Longer-lived but limited scope - like renewal tickets
- Store securely (HttpOnly cookies in browsers)
- Single-use when possible (rotate on refresh)

**🚨 Security Warnings**:
- Never put sensitive data in JWT payload (it's encoded, not encrypted!)
- Always verify token signature and expiration
- Use HTTPS only - magical scrolls need secure transport!

### 👤 Step 4: User Authentication

#### Authentication Dependencies

```python
# Mock database (replace with real database)
fake_users_db = {
    "admin": {
        "id": 1,
        "username": "admin",
        "email": "admin@example.com",
        "full_name": "Administrator",
        "hashed_password": pwd_context.hash("admin123!"),
        "roles": ["admin", "user"],
        "permissions": ["read", "write", "delete", "manage_users"],
        "is_active": True,
        "is_verified": True
    },
    "user": {
        "id": 2,
        "username": "user",
        "email": "user@example.com",
        "full_name": "Regular User",
        "hashed_password": pwd_context.hash("user123!"),
        "roles": ["user"],
        "permissions": ["read", "write"],
        "is_active": True,
        "is_verified": True
    }
}

def authenticate_user(username: str, password: str) -> Optional[User]:
    """Authenticate user with username and password"""
    user_data = fake_users_db.get(username)
    if not user_data:
        return None
    if not verify_password(password, user_data["hashed_password"]):
        return None
    return User(**user_data)

async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    """Get current authenticated user from JWT token"""
    token_data = verify_token(token)
    user_data = fake_users_db.get(token_data.username)
    
    if user_data is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found"
        )
    
    if not user_data["is_active"]:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Inactive user"
        )
    
    return User(**user_data)

async def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:
    """Ensure user is active and verified"""
    if not current_user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    return current_user
```

### 🛡️ Step 5: Authorization Patterns

#### Role-Based Access Control (RBAC)

```python
def require_roles(*required_roles: str):
    """Dependency to check if user has required roles"""
    def role_checker(current_user: User = Depends(get_current_active_user)) -> User:
        if not any(role in current_user.roles for role in required_roles):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Insufficient permissions. Required roles: {', '.join(required_roles)}"
            )
        return current_user
    return role_checker

def require_permissions(*required_permissions: str):
    """Dependency to check if user has required permissions"""
    def permission_checker(current_user: User = Depends(get_current_active_user)) -> User:
        missing_perms = [p for p in required_permissions if p not in current_user.permissions]
        if missing_perms:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Missing required permissions: {', '.join(missing_perms)}"
            )
        return current_user
    return permission_checker

def require_admin(current_user: User = Depends(get_current_active_user)) -> User:
    """Shortcut dependency for admin-only access"""
    if "admin" not in current_user.roles:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin access required"
        )
    return current_user
```

#### Resource-Level Authorization

```python
def can_access_resource(user: User, resource_id: int, action: str) -> bool:
    """Check if user can perform action on specific resource"""
    # Example logic - adapt to your needs
    if "admin" in user.roles:
        return True  # Admins can do anything
    
    if action == "read" and "read" in user.permissions:
        return True
    
    if action in ["create", "update", "delete"] and "write" in user.permissions:
        # Additional checks for resource ownership could go here
        return True
    
    return False

def require_resource_access(resource_id: int, action: str):
    """Dependency for resource-level authorization"""
    def resource_checker(current_user: User = Depends(get_current_active_user)) -> User:
        if not can_access_resource(current_user, resource_id, action):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Cannot {action} resource {resource_id}"
            )
        return current_user
    return resource_checker
```

### 🚀 Step 6: Authentication Endpoints

#### FastAPI Application Setup

```python
app = FastAPI(
    title="Secure Authentication API",
    description="Production-ready authentication and authorization",
    version="1.0.0"
)

# Rate limiting storage (use Redis in production)
login_attempts = {}

@app.post("/auth/register", response_model=dict)
async def register_user(user_data: UserCreate):
    """Register a new user"""
    # Check if user already exists
    if user_data.username in fake_users_db:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already registered"
        )
    
    # Validate password strength
    validate_password_strength(user_data.password)
    
    # Create new user
    hashed_password = get_password_hash(user_data.password)
    new_user = {
        "id": len(fake_users_db) + 1,
        "username": user_data.username,
        "email": user_data.email,
        "full_name": user_data.full_name,
        "hashed_password": hashed_password,
        "roles": ["user"],  # Default role
        "permissions": ["read"],  # Default permissions
        "is_active": True,
        "is_verified": False  # Require email verification
    }
    
    fake_users_db[user_data.username] = new_user
    
    return {
        "message": "User registered successfully",
        "username": user_data.username,
        "email": user_data.email
    }

@app.post("/auth/token", response_model=Token)
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    """Authenticate user and return access token"""
    # Rate limiting check
    client_ip = "127.0.0.1"  # In production, get real IP
    current_time = datetime.utcnow()
    
    if client_ip in login_attempts:
        attempts = login_attempts[client_ip]
        # Remove old attempts (older than 15 minutes)
        attempts = [attempt for attempt in attempts if current_time - attempt < timedelta(minutes=15)]
        
        if len(attempts) >= 5:  # Max 5 attempts per 15 minutes
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="Too many login attempts. Try again later."
            )
        
        login_attempts[client_ip] = attempts
    else:
        login_attempts[client_ip] = []
    
    # Authenticate user
    user = authenticate_user(form_data.username, form_data.password)
    if not user:
        # Record failed attempt
        login_attempts[client_ip].append(current_time)
        
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Clear failed attempts on successful login
    if client_ip in login_attempts:
        del login_attempts[client_ip]
    
    # Create tokens
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={
            "sub": user.username,
            "user_id": user.id,
            "roles": user.roles,
            "permissions": user.permissions
        },
        expires_delta=access_token_expires
    )
    
    refresh_token = create_refresh_token(
        data={"sub": user.username, "user_id": user.id}
    )
    
    return Token(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer",
        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

@app.post("/auth/refresh", response_model=dict)
async def refresh_access_token(refresh_token: str):
    """Refresh access token using refresh token"""
    token_data = verify_token(refresh_token, "refresh")
    
    user_data = fake_users_db.get(token_data.username)
    if not user_data or not user_data["is_active"]:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )
    
    # Create new access token
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={
            "sub": user_data["username"],
            "user_id": user_data["id"],
            "roles": user_data["roles"],
            "permissions": user_data["permissions"]
        },
        expires_delta=access_token_expires
    )
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60
    }
```

### 🔐 Step 7: Protected Endpoints

#### Different Authorization Levels

```python
@app.get("/auth/me", response_model=User)
async def get_current_user_info(current_user: User = Depends(get_current_active_user)):
    """Get current user information"""
    return current_user

@app.get("/users", response_model=List[dict])
async def get_users(current_user: User = Depends(require_permissions("read"))):
    """Get list of users - requires read permission"""
    return [
        {
            "id": user["id"],
            "username": user["username"],
            "email": user["email"],
            "full_name": user["full_name"],
            "roles": user["roles"],
            "is_active": user["is_active"]
        }
        for user in fake_users_db.values()
    ]

@app.post("/admin/users/{user_id}/roles")
async def assign_user_role(
    user_id: int,
    roles: List[str],
    current_user: User = Depends(require_admin)
):
    """Assign roles to user - admin only"""
    # Find user by ID
    target_user = None
    for user_data in fake_users_db.values():
        if user_data["id"] == user_id:
            target_user = user_data
            break
    
    if not target_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    # Update roles
    target_user["roles"] = roles
    
    return {
        "message": f"Roles updated for user {user_id}",
        "new_roles": roles
    }

@app.delete("/admin/users/{user_id}")
async def delete_user(
    user_id: int,
    current_user: User = Depends(require_roles("admin"))
):
    """Delete user - admin only"""
    # Prevent self-deletion
    if current_user.id == user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot delete your own account"
        )
    
    # Find and remove user
    username_to_delete = None
    for username, user_data in fake_users_db.items():
        if user_data["id"] == user_id:
            username_to_delete = username
            break
    
    if not username_to_delete:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    del fake_users_db[username_to_delete]
    
    return {"message": f"User {user_id} deleted successfully"}
```

### 🛡️ Step 8: Security Middleware

#### Security Headers and CORS

```python
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.base import BaseHTTPMiddleware

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    """Add security headers to all responses"""
    
    async def dispatch(self, request, call_next):
        response = await call_next(request)
        
        # Security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
        
        return response

# Add middleware
app.add_middleware(SecurityHeadersMiddleware)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://yourdomain.com"],  # Specify allowed origins
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)
```

## 🎯 Authentication Flow Summary

### Complete Authentication Process

```mermaid
sequenceDiagram
    participant Client
    participant API
    participant Auth
    participant DB
    
    Client->>API: POST /auth/register
    API->>Auth: Validate password
    Auth->>DB: Store user
    DB-->>API: User created
    API-->>Client: Registration success
    
    Client->>API: POST /auth/token
    API->>Auth: Verify credentials
    Auth->>DB: Check user
    DB-->>Auth: User data
    Auth->>Auth: Generate JWT
    Auth-->>API: Tokens
    API-->>Client: Access & Refresh tokens
    
    Client->>API: GET /protected (with token)
    API->>Auth: Verify token
    Auth->>Auth: Check permissions
    Auth-->>API: User authorized
    API-->>Client: Protected resource
```

### 📊 Security Features Implemented

| Feature | Purpose | Implementation |
|---------|---------|----------------|
| **Password Hashing** | Secure password storage | bcrypt with salt |
| **JWT Tokens** | Stateless authentication | HS256 algorithm |
| **Refresh Tokens** | Long-term sessions | Separate token type |
| **Role-Based Access** | Hierarchical permissions | Role checking dependencies |
| **Permission System** | Granular access control | Permission-based authorization |
| **Rate Limiting** | Brute force protection | Login attempt tracking |
| **Security Headers** | Web security | XSS, CSRF protection |
| **Password Validation** | Strong passwords | Pattern matching |

### 🚀 Production Considerations

#### ✅ Security Checklist
- [ ] Use environment variables for secrets
- [ ] Implement proper session management
- [ ] Add two-factor authentication
- [ ] Use HTTPS in production
- [ ] Implement proper logging and monitoring
- [ ] Add password reset functionality
- [ ] Implement account lockout policies
- [ ] Add email verification

#### ✅ Performance Optimizations
- [ ] Use Redis for session storage
- [ ] Implement token blacklisting
- [ ] Add database connection pooling
- [ ] Use caching for role/permission lookups
- [ ] Implement proper database indexing

### 🔍 Testing Your Authentication

```bash
# Register a new user
curl -X POST "http://localhost:8000/auth/register" \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "email": "test@example.com",
    "password": "Test123!",
    "full_name": "Test User"
  }'

# Login to get tokens
curl -X POST "http://localhost:8000/auth/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=testuser&password=Test123!"

# Access protected endpoint
curl -X GET "http://localhost:8000/auth/me" \
  -H "Authorization: Bearer <your-access-token>"

# Admin endpoint
curl -X GET "http://localhost:8000/users" \
  -H "Authorization: Bearer <admin-token>"
```

---

> 🎉 **Congratulations!** You've implemented a comprehensive authentication and authorization system with FastAPI. This system includes secure password handling, JWT tokens, role-based access control, and production-ready security features.

**Next**: Explore [Security Considerations](/docs/03_intermediate/05-security-considerations) to further harden your API security! 🛡️