# Response Format Standards

## Consistent Response Structure

Implement envelope patterns for consistent API responses:

```python
from fastapi import FastAPI, HTTPException, Request, status
from pydantic import BaseModel
from typing import Optional, Dict, Any, List, Union
from datetime import datetime
import uuid

class APIResponse(BaseModel):
    """Standard API response envelope"""
    success: bool
    data: Optional[Union[Dict, List, str, int]] = None
    error: Optional[Dict[str, Any]] = None
    metadata: Dict[str, Any] = {}
    
    class Config:
        schema_extra = {
            "example": {
                "success": True,
                "data": {"id": 1, "name": "John"},
                "error": None,
                "metadata": {
                    "timestamp": "2024-01-15T10:30:00Z",
                    "request_id": "req_123",
                    "api_version": "v1",
                    "execution_time_ms": 150
                }
            }
        }

class PaginatedResponse(BaseModel):
    """Response with pagination metadata"""
    success: bool = True
    data: List[Dict[str, Any]]
    pagination: Dict[str, Any]
    metadata: Dict[str, Any] = {}

def create_response(
    data: Any = None,
    error: Dict = None,
    request: Request = None,
    execution_time: Optional[float] = None
) -> APIResponse:
    """Helper function to create consistent responses"""
    
    metadata = {
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "api_version": "v1"
    }
    
    if request:
        # Generate request ID if not present
        request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))
        metadata["request_id"] = request_id
        
    if execution_time:
        metadata["execution_time_ms"] = round(execution_time * 1000, 2)
    
    return APIResponse(
        success=error is None,
        data=data,
        error=error,
        metadata=metadata
    )

@app.get("/users/{user_id}", response_model=APIResponse)
async def get_user_with_envelope(user_id: int, request: Request):
    """Example with response envelope"""
    
    # Simulate processing time
    import time
    start_time = time.time()
    
    try:
        # Simulate database lookup
        if user_id == 999:
            raise HTTPException(status_code=404, detail="User not found")
        
        user_data = {
            "id": user_id,
            "username": f"user_{user_id}",
            "email": f"user_{user_id}@example.com",
            "created_at": "2024-01-01T00:00:00Z"
        }
        
        execution_time = time.time() - start_time
        return create_response(
            data=user_data,
            request=request,
            execution_time=execution_time
        )
        
    except HTTPException as e:
        execution_time = time.time() - start_time
        error_data = {
            "code": "USER_NOT_FOUND",
            "message": e.detail,
            "status_code": e.status_code
        }
        return create_response(
            error=error_data,
            request=request,
            execution_time=execution_time
        )

@app.get("/users", response_model=PaginatedResponse)
async def get_users_paginated(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    request: Request = None
):
    """Paginated response example"""
    
    # Simulate data fetching
    total_users = 150
    start_index = (page - 1) * limit
    end_index = min(start_index + limit, total_users)
    
    users = [
        {"id": i, "username": f"user_{i}", "email": f"user_{i}@example.com"}
        for i in range(start_index + 1, end_index + 1)
    ]
    
    return PaginatedResponse(
        data=users,
        pagination={
            "page": page,
            "limit": limit,
            "total": total_users,
            "pages": (total_users + limit - 1) // limit,
            "has_next": end_index < total_users,
            "has_prev": page > 1,
            "next_page": page + 1 if end_index < total_users else None,
            "prev_page": page - 1 if page > 1 else None
        },
        metadata={
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "request_id": request.headers.get("X-Request-ID", str(uuid.uuid4())) if request else None
        }
    )
```

## HATEOAS Implementation

Include hypermedia controls for discoverability:

```python
from fastapi import FastAPI, Request
from pydantic import BaseModel
from typing import List, Dict, Optional

class Link(BaseModel):
    href: str
    rel: str
    method: str = "GET"
    type: str = "application/json"

class HATEOASResource(BaseModel):
    """Base model with HATEOAS links"""
    _links: Dict[str, Link] = {}

class UserResource(HATEOASResource):
    id: int
    username: str
    email: str
    status: str

def generate_user_links(user_id: int, base_url: str) -> Dict[str, Link]:
    """Generate HATEOAS links for user resource"""
    return {
        "self": Link(
            href=f"{base_url}/api/v1/users/{user_id}",
            rel="self"
        ),
        "edit": Link(
            href=f"{base_url}/api/v1/users/{user_id}",
            rel="edit",
            method="PUT"
        ),
        "delete": Link(
            href=f"{base_url}/api/v1/users/{user_id}",
            rel="delete",
            method="DELETE"
        ),
        "orders": Link(
            href=f"{base_url}/api/v1/users/{user_id}/orders",
            rel="related"
        ),
        "profile": Link(
            href=f"{base_url}/api/v1/users/{user_id}/profile",
            rel="related"
        )
    }

@app.get("/users/{user_id}", response_model=UserResource)
async def get_user_hateoas(user_id: int, request: Request):
    """User endpoint with HATEOAS links"""
    
    base_url = f"{request.url.scheme}://{request.url.netloc}"
    
    user = UserResource(
        id=user_id,
        username=f"user_{user_id}",
        email=f"user_{user_id}@example.com",
        status="active",
        _links=generate_user_links(user_id, base_url)
    )
    
    # Add conditional links based on user status
    if user.status == "active":
        user._links["deactivate"] = Link(
            href=f"{base_url}/api/v1/users/{user_id}/deactivate",
            rel="action",
            method="POST"
        )
    elif user.status == "inactive":
        user._links["activate"] = Link(
            href=f"{base_url}/api/v1/users/{user_id}/activate",
            rel="action",
            method="POST"
        )
    
    return user
```