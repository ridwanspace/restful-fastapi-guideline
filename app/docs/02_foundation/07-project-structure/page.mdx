# Project Structure

A well-organized project structure is crucial for building maintainable, scalable FastAPI applications. Good structure makes your code easier to understand, test, and collaborate on. It also helps enforce separation of concerns and makes your application more modular and extensible.

## Why Project Structure Matters

- **Maintainability**: Clear organization makes code easier to modify and debug
- **Scalability**: Modular structure supports growing application complexity
- **Team Collaboration**: Consistent patterns help team members navigate the codebase
- **Testing**: Organized code is easier to test with clear boundaries
- **Deployment**: Structured projects are simpler to containerize and deploy

## Basic FastAPI Project Structure

Start with this foundational structure for small to medium applications:

```
my-fastapi-app/
├── app/
│   ├── __init__.py
│   ├── main.py              # FastAPI app instance and configuration
│   ├── dependencies.py      # Shared dependencies
│   ├── config.py           # Configuration settings
│   ├── models/             # Database models
│   │   ├── __init__.py
│   │   ├── user.py
│   │   └── product.py
│   ├── schemas/            # Pydantic schemas
│   │   ├── __init__.py
│   │   ├── user.py
│   │   └── product.py
│   ├── routers/            # API route handlers
│   │   ├── __init__.py
│   │   ├── users.py
│   │   └── products.py
│   ├── services/           # Business logic
│   │   ├── __init__.py
│   │   ├── user_service.py
│   │   └── product_service.py
│   └── utils/              # Utility functions
│       ├── __init__.py
│       ├── security.py
│       └── database.py
├── tests/
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_users.py
│   └── test_products.py
├── alembic/                # Database migrations
├── requirements.txt
├── .env
├── .gitignore
├── README.md
└── Dockerfile
```

## Core Application Files

### app/main.py - Application Entry Point

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.routers import users, products
from app.config import settings
from app.utils.database import engine, Base

# Create database tables
Base.metadata.create_all(bind=engine)

app = FastAPI(
    title=settings.PROJECT_NAME,
    version=settings.VERSION,
    description="A well-structured FastAPI application"
)

# Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_HOSTS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(users.router, prefix="/api/v1", tags=["users"])
app.include_router(products.router, prefix="/api/v1", tags=["products"])

@app.get("/")
async def root():
    return {"message": "Welcome to the FastAPI application"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}
```

### app/config.py - Configuration Management

```python
from pydantic_settings import BaseSettings
from typing import List

class Settings(BaseSettings):
    PROJECT_NAME: str = "FastAPI Application"
    VERSION: str = "1.0.0"
    
    # Database
    DATABASE_URL: str = "sqlite:///./test.db"
    
    # Security
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # CORS
    ALLOWED_HOSTS: List[str] = ["*"]
    
    # Environment
    ENVIRONMENT: str = "development"
    DEBUG: bool = True
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()
```

### app/dependencies.py - Shared Dependencies

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from app.utils.database import get_db
from app.utils.security import verify_token
from app.models.user import User

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """Get the current authenticated user"""
    token = credentials.credentials
    user_id = verify_token(token)
    
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials"
        )
    
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user

def get_admin_user(current_user: User = Depends(get_current_user)) -> User:
    """Ensure the current user has admin privileges"""
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    return current_user
```

## Models Layer - Database Models

### app/models/user.py

```python
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from sqlalchemy.sql import func
from app.utils.database import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    is_admin = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
```

### app/models/product.py

```python
from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.utils.database import Base

class Product(Base):
    __tablename__ = "products"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True, nullable=False)
    description = Column(String)
    price = Column(Float, nullable=False)
    is_available = Column(Boolean, default=True)
    owner_id = Column(Integer, ForeignKey("users.id"))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    owner = relationship("User", back_populates="products")
```

## Schemas Layer - Request/Response Models

### app/schemas/user.py

```python
from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional

class UserBase(BaseModel):
    email: EmailStr
    username: str

class UserCreate(UserBase):
    password: str

class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    username: Optional[str] = None
    is_active: Optional[bool] = None

class UserResponse(UserBase):
    id: int
    is_active: bool
    is_admin: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

class UserInDB(UserResponse):
    hashed_password: str
```

### app/schemas/product.py

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class ProductBase(BaseModel):
    name: str
    description: Optional[str] = None
    price: float

class ProductCreate(ProductBase):
    pass

class ProductUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    price: Optional[float] = None
    is_available: Optional[bool] = None

class ProductResponse(ProductBase):
    id: int
    is_available: bool
    owner_id: int
    created_at: datetime
    
    class Config:
        from_attributes = True
```

## Services Layer - Business Logic

### app/services/user_service.py

```python
from sqlalchemy.orm import Session
from app.models.user import User
from app.schemas.user import UserCreate, UserUpdate
from app.utils.security import hash_password
from fastapi import HTTPException, status

class UserService:
    def __init__(self, db: Session):
        self.db = db
    
    def create_user(self, user_data: UserCreate) -> User:
        """Create a new user"""
        # Check if user already exists
        existing_user = self.db.query(User).filter(
            (User.email == user_data.email) | 
            (User.username == user_data.username)
        ).first()
        
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User with this email or username already exists"
            )
        
        # Create new user
        hashed_password = hash_password(user_data.password)
        db_user = User(
            email=user_data.email,
            username=user_data.username,
            hashed_password=hashed_password
        )
        
        self.db.add(db_user)
        self.db.commit()
        self.db.refresh(db_user)
        
        return db_user
    
    def get_user_by_id(self, user_id: int) -> User:
        """Get user by ID"""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        return user
    
    def update_user(self, user_id: int, user_data: UserUpdate) -> User:
        """Update user information"""
        user = self.get_user_by_id(user_id)
        
        update_data = user_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(user, field, value)
        
        self.db.commit()
        self.db.refresh(user)
        
        return user
    
    def delete_user(self, user_id: int) -> bool:
        """Delete a user"""
        user = self.get_user_by_id(user_id)
        self.db.delete(user)
        self.db.commit()
        return True
```

## Routers Layer - API Endpoints

### app/routers/users.py

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from app.schemas.user import UserCreate, UserResponse, UserUpdate
from app.services.user_service import UserService
from app.utils.database import get_db
from app.dependencies import get_current_user, get_admin_user
from app.models.user import User

router = APIRouter()

@router.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(
    user_data: UserCreate,
    db: Session = Depends(get_db)
):
    """Create a new user"""
    user_service = UserService(db)
    return user_service.create_user(user_data)

@router.get("/users/me", response_model=UserResponse)
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """Get current user information"""
    return current_user

@router.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_admin_user)
):
    """Get user by ID (admin only)"""
    user_service = UserService(db)
    return user_service.get_user_by_id(user_id)

@router.put("/users/{user_id}", response_model=UserResponse)
async def update_user(
    user_id: int,
    user_data: UserUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Update user information"""
    # Users can only update their own profile unless they're admin
    if user_id != current_user.id and not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    
    user_service = UserService(db)
    return user_service.update_user(user_id, user_data)

@router.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_admin_user)
):
    """Delete a user (admin only)"""
    user_service = UserService(db)
    user_service.delete_user(user_id)
```

## Utilities Layer

### app/utils/database.py

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.config import settings

engine = create_engine(
    settings.DATABASE_URL,
    connect_args={"check_same_thread": False} if "sqlite" in settings.DATABASE_URL else {}
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    """Database dependency"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### app/utils/security.py

```python
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
from app.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash"""
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict) -> str:
    """Create a JWT access token"""
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def verify_token(token: str) -> int:
    """Verify and decode a JWT token"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: int = payload.get("sub")
        if user_id is None:
            return None
        return user_id
    except JWTError:
        return None
```

## Advanced Project Structure

For larger applications, consider this extended structure:

```
my-large-fastapi-app/
├── app/
│   ├── __init__.py
│   ├── main.py
│   ├── config.py
│   ├── dependencies.py
│   ├── core/                 # Core functionality
│   │   ├── __init__.py
│   │   ├── security.py
│   │   ├── config.py
│   │   └── events.py
│   ├── api/                  # API layer
│   │   ├── __init__.py
│   │   ├── api_v1/
│   │   │   ├── __init__.py
│   │   │   ├── api.py
│   │   │   └── endpoints/
│   │   │       ├── users.py
│   │   │       ├── products.py
│   │   │       └── orders.py
│   │   └── deps.py
│   ├── models/               # Database models
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── user.py
│   │   ├── product.py
│   │   └── order.py
│   ├── schemas/              # Pydantic schemas
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── product.py
│   │   └── order.py
│   ├── services/             # Business logic
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── user_service.py
│   │   ├── product_service.py
│   │   └── order_service.py
│   ├── repositories/         # Data access layer
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── user_repository.py
│   │   └── product_repository.py
│   ├── middleware/           # Custom middleware
│   │   ├── __init__.py
│   │   ├── logging.py
│   │   └── rate_limiting.py
│   ├── exceptions/           # Custom exceptions
│   │   ├── __init__.py
│   │   ├── base.py
│   │   └── handlers.py
│   └── utils/
│       ├── __init__.py
│       ├── database.py
│       ├── email.py
│       └── validators.py
├── tests/
│   ├── __init__.py
│   ├── conftest.py
│   ├── unit/
│   ├── integration/
│   └── e2e/
├── migrations/               # Alembic migrations
├── scripts/                  # Utility scripts
├── docs/                     # Documentation
├── docker/
├── .github/workflows/        # CI/CD
├── requirements/
│   ├── base.txt
│   ├── dev.txt
│   └── prod.txt
└── docker-compose.yml
```

## Repository Pattern Implementation

For complex applications, implement the repository pattern:

### app/repositories/base.py

```python
from typing import Generic, TypeVar, Type, List, Optional
from sqlalchemy.orm import Session
from sqlalchemy.ext.declarative import declarative_base

ModelType = TypeVar("ModelType", bound=declarative_base())

class BaseRepository(Generic[ModelType]):
    def __init__(self, model: Type[ModelType], db: Session):
        self.model = model
        self.db = db
    
    def get(self, id: int) -> Optional[ModelType]:
        return self.db.query(self.model).filter(self.model.id == id).first()
    
    def get_all(self, skip: int = 0, limit: int = 100) -> List[ModelType]:
        return self.db.query(self.model).offset(skip).limit(limit).all()
    
    def create(self, obj_in: dict) -> ModelType:
        db_obj = self.model(**obj_in)
        self.db.add(db_obj)
        self.db.commit()
        self.db.refresh(db_obj)
        return db_obj
    
    def update(self, db_obj: ModelType, obj_in: dict) -> ModelType:
        for field, value in obj_in.items():
            setattr(db_obj, field, value)
        self.db.commit()
        self.db.refresh(db_obj)
        return db_obj
    
    def delete(self, id: int) -> bool:
        obj = self.db.query(self.model).filter(self.model.id == id).first()
        if obj:
            self.db.delete(obj)
            self.db.commit()
            return True
        return False
```

## Best Practices

### ✅ Do's

1. **Consistent Naming**: Use clear, consistent naming conventions across all layers
2. **Separation of Concerns**: Keep models, schemas, services, and routers separate
3. **Dependency Injection**: Use FastAPI's dependency injection for better testability
4. **Configuration Management**: Centralize configuration with environment variables
5. **Error Handling**: Implement consistent error handling across the application

```python
# Good: Clear separation of concerns
# Router handles HTTP concerns
@router.post("/users", response_model=UserResponse)
async def create_user(user_data: UserCreate, db: Session = Depends(get_db)):
    user_service = UserService(db)  # Service handles business logic
    return user_service.create_user(user_data)

# Service handles business logic
class UserService:
    def create_user(self, user_data: UserCreate) -> User:
        # Business logic here
        return self.repository.create(user_data.dict())
```

### ❌ Don'ts

1. **Don't Mix Concerns**: Avoid putting business logic in routers or database logic in services
2. **Don't Hardcode Values**: Use configuration files for all settings
3. **Don't Ignore Testing**: Structure should support easy testing
4. **Don't Over-complicate**: Start simple and add complexity as needed

```python
# Bad: Business logic in router
@router.post("/users")
async def create_user(user_data: UserCreate, db: Session = Depends(get_db)):
    # Don't put business logic here
    if db.query(User).filter(User.email == user_data.email).first():
        raise HTTPException(status_code=400, detail="User exists")
    
    hashed_password = hash_password(user_data.password)
    user = User(email=user_data.email, hashed_password=hashed_password)
    db.add(user)
    db.commit()
    return user
```

## Environment-Specific Configuration

### .env.development

```bash
DATABASE_URL=sqlite:///./dev.db
SECRET_KEY=dev-secret-key
DEBUG=true
ENVIRONMENT=development
ALLOWED_HOSTS=["localhost", "127.0.0.1"]
```

### .env.production

```bash
DATABASE_URL=postgresql://user:password@postgres:5432/prod_db
SECRET_KEY=super-secret-production-key
DEBUG=false
ENVIRONMENT=production
ALLOWED_HOSTS=["yourdomain.com", "api.yourdomain.com"]
```

## Try It Yourself

1. **Create a basic project structure** for a task management API
2. **Implement the repository pattern** for your models
3. **Add environment-specific configuration** for development and production
4. **Organize a multi-version API** with proper folder structure
5. **Build a modular authentication system** using the service layer pattern

Practice these patterns to build maintainable, scalable FastAPI applications that can grow with your requirements while remaining organized and testable.