# 🏢 FastAPI Project Structure: Building Your Digital Organization

## 🎯 The Company Analogy: Understanding Project Organization

Think of a FastAPI project like organizing a modern tech company. Just as a successful company needs clear departments, defined roles, and efficient communication channels, your FastAPI application needs a well-structured codebase where every component has a specific purpose and knows how to interact with others.

### 📊 Visual Overview: The Corporate Structure

```mermaid
graph TD
    A[🏢 FastAPI Company] --> B[🎭 Frontend/API Layer<br/>Customer Service]
    A --> C[🧠 Business Logic Layer<br/>Operations Department]
    A --> D[🗄️ Data Layer<br/>Records Department]
    A --> E[🔧 Infrastructure Layer<br/>IT Department]
    
    B --> B1[🛣️ Routers<br/>Reception Desk]
    B --> B2[📋 Schemas<br/>Customer Forms]
    
    C --> C1[⚙️ Services<br/>Business Units]
    C --> C2[🎯 Dependencies<br/>Shared Resources]
    
    D --> D1[🏗️ Models<br/>Filing System]
    D --> D2[🗃️ Repositories<br/>Data Archives]
    
    E --> E1[⚙️ Config<br/>Company Policies]
    E --> E2[🛠️ Utils<br/>IT Tools]
    
    style A fill:#e3f2fd
    style B fill:#f3e5f5
    style C fill:#e8f5e8
    style D fill:#fff3e0
    style E fill:#fce4ec
```

### 🏗️ Why Project Structure Matters: The Business Case

**Think of it this way:** A disorganized company fails because:
- Employees don't know their responsibilities (unclear separation of concerns)
- Departments duplicate work (code repetition)
- Communication breaks down (tight coupling)
- New hires get lost (poor maintainability)
- Growth becomes chaotic (scaling issues)

**Your FastAPI project structure solves these same problems:**
- **🎯 Maintainability**: Like clear job descriptions, organized code makes responsibilities obvious
- **📈 Scalability**: Like departmental structure, modular design supports growth
- **👥 Team Collaboration**: Like company handbooks, consistent patterns help teams navigate
- **🧪 Testing**: Like quality control departments, organized code enables systematic testing
- **🚀 Deployment**: Like efficient logistics, structured projects deploy smoothly

## 🌱 Progressive Learning Path: From Startup to Enterprise

### 🚀 Level 1: The Startup (Basic Structure)
*Perfect for: Learning FastAPI, small projects, MVPs*

**🏢 Company Analogy:** Your startup has just secured funding! You need to organize your small team efficiently. Everyone wears multiple hats, but each person has clear primary responsibilities.

### 📁 The Startup Office Layout

```mermaid
graph LR
    subgraph "🏢 Your FastAPI Startup"
        A[📂 app/<br/>🏢 Main Office] --> B[📄 main.py<br/>🚪 Front Door]
        A --> C[📋 schemas/<br/>📋 Customer Forms]
        A --> D[🛣️ routers/<br/>🎭 Sales Team]
        A --> E[⚙️ services/<br/>🧠 Operations]
        A --> F[🗄️ models/<br/>📚 Records]
        A --> G[🔧 utils/<br/>🛠️ IT Corner]
        
        H[🧪 tests/<br/>🔍 QA Department] 
        I[📦 requirements.txt<br/>📋 Supply List]
        J[⚙️ .env<br/>🔐 Company Secrets]
    end
    
    style A fill:#e3f2fd
    style B fill:#c8e6c9
    style H fill:#fff3e0
```

### 🗂️ Your Startup's Directory Structure

```
my-fastapi-startup/
├── 🏢 app/                    # Main office building
│   ├── 📄 __init__.py         # Office registry
│   ├── 🚪 main.py             # Front entrance & reception
│   ├── 🎯 dependencies.py     # Shared company resources
│   ├── ⚙️ config.py           # Company policies & settings
│   ├── 🗄️ models/             # Filing cabinet (database structure)
│   │   ├── 📄 __init__.py
│   │   ├── 👤 user.py         # Employee records format
│   │   └── 📦 product.py      # Product catalog format
│   ├── 📋 schemas/            # Customer interaction forms
│   │   ├── 📄 __init__.py
│   │   ├── 👤 user.py         # User registration forms
│   │   └── 📦 product.py      # Product order forms
│   ├── 🛣️ routers/            # Customer service desks
│   │   ├── 📄 __init__.py
│   │   ├── 👥 users.py        # User service counter
│   │   └── 🛒 products.py     # Product service counter
│   ├── ⚙️ services/           # Business operations team
│   │   ├── 📄 __init__.py
│   │   ├── 👤 user_service.py # User management operations
│   │   └── 📦 product_service.py # Product management operations
│   └── 🔧 utils/              # IT support utilities
│       ├── 📄 __init__.py
│       ├── 🔐 security.py     # Security tools
│       └── 🗃️ database.py     # Database connections
├── 🧪 tests/                  # Quality assurance department
│   ├── 📄 __init__.py
│   ├── ⚙️ conftest.py         # Testing infrastructure
│   ├── 👥 test_users.py       # User feature testing
│   └── 🛒 test_products.py    # Product feature testing
├── 🔄 alembic/                # Database change management
├── 📋 requirements.txt        # Supply list (dependencies)
├── 🔐 .env                    # Company secrets (environment variables)
├── 🚫 .gitignore             # What NOT to share publicly
├── 📖 README.md              # Company handbook
└── 🐳 Dockerfile             # Deployment packaging instructions
```

💡 **Startup Wisdom:** Keep it simple! Your startup structure should be easy to navigate. Every file has a clear purpose, just like every employee has a clear role.

## 🏗️ Core Application Files: Your Startup's Foundation

### 🚪 app/main.py - The Front Door & Reception

**🏢 Company Analogy:** Think of `main.py` as your company's front entrance and reception area. It's where visitors first arrive, security checks happen, and people get directed to the right department.

```mermaid
graph LR
    A[🌐 Internet Request] --> B[🚪 main.py<br/>Reception]
    B --> C[🛡️ Middleware<br/>Security Check]
    C --> D[🎭 Router<br/>Directory Service]
    D --> E[⚙️ Service<br/>Department]
    E --> F[📤 Response<br/>Visitor Badge]
    
    style B fill:#e3f2fd
    style C fill:#fff3e0
    style D fill:#e8f5e8
```

### 🔧 Enhanced Code Example

```python
# Import the FastAPI framework - like installing a reception desk system
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from typing import Dict, Any
import logging

# Import your company departments (routers)
from app.routers import users, products
from app.config import settings
from app.utils.database import engine, Base

# Configure logging - like setting up your company's communication system
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Initialize your company's infrastructure (database tables)
# Like setting up your filing system before opening for business
try:
    Base.metadata.create_all(bind=engine)
    logger.info("📁 Database tables created successfully - filing system ready!")
except Exception as e:
    logger.error(f"❌ Failed to create database tables: {e}")
    raise

# Create your company headquarters - the main FastAPI application
app = FastAPI(
    title=settings.PROJECT_NAME,  # Your company name
    version=settings.VERSION,     # Like your business license version
    description="A well-structured FastAPI application serving digital excellence",
    docs_url="/api/docs",         # Where employees can read the company manual
    redoc_url="/api/redoc",       # Alternative company manual format
    openapi_url="/api/openapi.json"  # Machine-readable company structure
)

# Set up security and access control - like your company's visitor policy
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_HOSTS,  # Which other companies can visit
    allow_credentials=True,                  # Allow visitors to show ID
    allow_methods=["GET", "POST", "PUT", "DELETE"],  # What visitors can do
    allow_headers=["*"],                     # What information visitors can bring
)

# Register your company departments (routers)
# Like adding departments to your company directory
app.include_router(
    users.router, 
    prefix="/api/v1",           # Department address
    tags=["users"],             # Department category
    responses={404: {"description": "User not found"}}  # Standard responses
)

app.include_router(
    products.router, 
    prefix="/api/v1", 
    tags=["products"],
    responses={404: {"description": "Product not found"}}
)

# Company welcome desk - the first thing visitors see
@app.get("/", response_model=Dict[str, Any], tags=["general"])
async def company_welcome() -> Dict[str, Any]:
    """
    Welcome endpoint - like a friendly receptionist greeting.
    
    Returns company information and available services.
    Perfect for checking if your API is running correctly.
    """
    return {
        "message": f"🏢 Welcome to {settings.PROJECT_NAME}!",
        "version": settings.VERSION,
        "environment": settings.ENVIRONMENT,
        "status": "🟢 Online and ready to serve",
        "documentation": "/api/docs",
        "services": {
            "users": "/api/v1/users",
            "products": "/api/v1/products"
        }
    }

# Health check - like a security guard checking if everything is working
@app.get("/health", response_model=Dict[str, str], tags=["monitoring"])
async def health_check() -> Dict[str, str]:
    """
    Health check endpoint - like checking if all company systems are operational.
    
    Used by:
    - Monitoring systems (like security cameras)
    - Load balancers (like traffic controllers) 
    - Container orchestrators (like building managers)
    """
    try:
        # You could add more sophisticated health checks here
        # Like checking database connectivity, external services, etc.
        return {
            "status": "🟢 healthy",
            "timestamp": str(datetime.utcnow()),
            "service": settings.PROJECT_NAME
        }
    except Exception as e:
        logger.error(f"❌ Health check failed: {e}")
        return {
            "status": "🔴 unhealthy", 
            "error": str(e),
            "timestamp": str(datetime.utcnow())
        }

# Startup event - like opening ceremony when company starts operations
@app.on_event("startup")
async def startup_event():
    """Execute when the company opens for business."""
    logger.info(f"🚀 {settings.PROJECT_NAME} is starting up...")
    logger.info(f"📊 Environment: {settings.ENVIRONMENT}")
    logger.info(f"🗄️ Database: Connected and ready")

# Shutdown event - like closing procedures when company shuts down
@app.on_event("shutdown")
async def shutdown_event():
    """Execute when the company closes for business."""
    logger.info(f"📴 {settings.PROJECT_NAME} is shutting down...")
    logger.info("💾 All data has been safely stored")
```

### ✅ What This Front Door Does

Just like a well-organized company reception:

1. **🚪 Welcomes Visitors** - The root endpoint greets API users
2. **🛡️ Security Check** - CORS middleware controls access
3. **📋 Directory Service** - Routers direct requests to right departments
4. **🏥 Health Monitoring** - Health check ensures everything works
5. **📚 Documentation** - Auto-generated API docs for visitors
6. **🔄 Lifecycle Management** - Startup/shutdown events manage resources

💡 **Reception Best Practice:** Your main.py should be clean and focused. Like a good receptionist, it should know where to direct people but not handle every company operation itself.

### ⚙️ app/config.py - Company Policies & Settings

**🏢 Company Analogy:** Think of `config.py` as your company's official policy handbook. It contains all the rules, settings, and guidelines that govern how your business operates. Just like a real company handbook, it should be centralized, versioned, and environment-specific.

```mermaid
graph TD
    A[⚙️ config.py<br/>📋 Policy Handbook] --> B[🔐 Security Policies<br/>🔑 Keys & Auth]
    A --> C[🗄️ Database Settings<br/>📊 Data Storage Rules]
    A --> D[🌐 CORS Rules<br/>🚪 Access Control]
    A --> E[🏢 Company Info<br/>📝 Basic Details]
    A --> F[🌍 Environment Config<br/>🎯 Context Settings]
    
    style A fill:#e3f2fd
    style B fill:#ffebee
    style C fill:#f3e5f5
```

### 🔧 Enhanced Configuration Code

```python
# Import Pydantic settings for configuration management
# Like having a smart policy system that validates all company rules
from pydantic_settings import BaseSettings
from typing import List, Optional
from pathlib import Path
import secrets

class Settings(BaseSettings):
    """
    Company Configuration - The Official Policy Handbook
    
    This class defines all the settings that control how your FastAPI
    company operates. Think of it as your business operations manual.
    """
    
    # 🏢 Company Identity Settings - Like your business registration
    PROJECT_NAME: str = "FastAPI Corporate Solutions"
    VERSION: str = "1.0.0"
    DESCRIPTION: str = "A professionally structured FastAPI application"
    
    # 🗄️ Database Configuration - Like your filing system setup
    DATABASE_URL: str = "sqlite:///./company_data.db"
    DATABASE_POOL_SIZE: int = 10          # How many database connections to maintain
    DATABASE_MAX_OVERFLOW: int = 20       # Maximum extra connections when busy
    DATABASE_ECHO: bool = False           # Whether to log all SQL queries (like audit trail)
    
    # 🔐 Security Policies - Like your company's security protocols
    SECRET_KEY: str = secrets.token_urlsafe(32)  # Secure default, override in production
    ALGORITHM: str = "HS256"                     # JWT signing algorithm
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30        # How long login sessions last
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7           # How long refresh tokens last
    PASSWORD_MIN_LENGTH: int = 8                 # Minimum password requirements
    
    # 🌐 CORS (Cross-Origin Resource Sharing) - Like visitor access policies
    ALLOWED_HOSTS: List[str] = ["*"]            # Which domains can access your API
    ALLOWED_METHODS: List[str] = ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
    ALLOWED_HEADERS: List[str] = ["*"]
    
    # 🌍 Environment Configuration - Like different office locations
    ENVIRONMENT: str = "development"             # development, staging, production
    DEBUG: bool = True                           # Enable detailed error messages
    TESTING: bool = False                        # Are we running tests?
    
    # 📧 Email Configuration - Like your company's communication system
    MAIL_USERNAME: Optional[str] = None
    MAIL_PASSWORD: Optional[str] = None
    MAIL_FROM: Optional[str] = None
    MAIL_PORT: int = 587
    MAIL_SERVER: Optional[str] = None
    MAIL_TLS: bool = True
    MAIL_SSL: bool = False
    
    # 📊 Logging Configuration - Like your company's record-keeping
    LOG_LEVEL: str = "INFO"                     # How detailed should logs be?
    LOG_FILE: Optional[str] = "app.log"         # Where to store log files
    
    # 🚀 Performance Settings - Like your company's efficiency policies
    WORKERS: int = 1                            # Number of worker processes
    MAX_CONNECTIONS_COUNT: int = 10             # Maximum concurrent connections
    MIN_CONNECTIONS_COUNT: int = 10             # Minimum connection pool size
    
    # 📁 File Storage - Like your company's document management
    UPLOAD_DIR: Path = Path("uploads")
    MAX_FILE_SIZE: int = 10 * 1024 * 1024      # 10MB max file size
    ALLOWED_FILE_TYPES: List[str] = [".jpg", ".png", ".pdf", ".txt"]
    
    # 🔄 Cache Configuration - Like your company's memory system
    REDIS_URL: Optional[str] = None
    CACHE_EXPIRE_IN_SECONDS: int = 3600         # 1 hour default cache
    
    # 🎯 API Rate Limiting - Like controlling visitor frequency
    RATE_LIMIT_PER_MINUTE: int = 100            # Requests per minute per user
    RATE_LIMIT_BURST: int = 200                 # Maximum burst requests
    
    @property
    def is_production(self) -> bool:
        """Check if we're running in production - like checking office location."""
        return self.ENVIRONMENT.lower() == "production"
    
    @property
    def is_development(self) -> bool:
        """Check if we're in development mode - like checking if we're in test office."""
        return self.ENVIRONMENT.lower() == "development"
    
    @property
    def database_config(self) -> dict:
        """Get database configuration - like getting filing cabinet setup details."""
        config = {
            "url": self.DATABASE_URL,
            "echo": self.DATABASE_ECHO,
        }
        
        # Add connection pooling for production databases
        if not self.DATABASE_URL.startswith("sqlite"):
            config.update({
                "pool_size": self.DATABASE_POOL_SIZE,
                "max_overflow": self.DATABASE_MAX_OVERFLOW,
                "pool_pre_ping": True,  # Verify connections before use
                "pool_recycle": 3600,   # Recycle connections every hour
            })
        
        return config
    
    def get_cors_config(self) -> dict:
        """Get CORS configuration - like getting visitor access rules."""
        return {
            "allow_origins": self.ALLOWED_HOSTS,
            "allow_credentials": True,
            "allow_methods": self.ALLOWED_METHODS,
            "allow_headers": self.ALLOWED_HEADERS,
        }
    
    class Config:
        """Configuration for the Settings class itself."""
        env_file = ".env"                       # Load settings from .env file
        env_file_encoding = "utf-8"             # File encoding
        case_sensitive = True                   # Environment variables are case-sensitive
        validate_assignment = True              # Validate when settings change
        
        # Example environment variable mapping
        fields = {
            "SECRET_KEY": {"env": ["SECRET_KEY", "API_SECRET_KEY"]},
            "DATABASE_URL": {"env": ["DATABASE_URL", "DB_URL"]},
        }

# Create the global settings instance - like publishing your company handbook
settings = Settings()

# Validation function - like having a policy compliance checker
def validate_settings():
    """
    Validate critical settings - like checking if company policies make sense.
    
    Raises:
        ValueError: If critical settings are missing or invalid
    """
    if settings.is_production:
        # In production, we need secure settings
        if settings.SECRET_KEY == "changeme" or len(settings.SECRET_KEY) < 32:
            raise ValueError("🔴 Production requires a secure SECRET_KEY!")
        
        if settings.DEBUG:
            raise ValueError("🔴 Never run production with DEBUG=True!")
        
        if "*" in settings.ALLOWED_HOSTS:
            raise ValueError("🔴 Production should not allow all hosts!")
    
    # Ensure upload directory exists
    settings.UPLOAD_DIR.mkdir(exist_ok=True)
    
    return True

# Auto-validate on import - like automatic policy checking
try:
    validate_settings()
    print(f"✅ Configuration validated for {settings.ENVIRONMENT} environment")
except ValueError as e:
    print(f"⚠️ Configuration warning: {e}")
```

### ✅ What This Policy Handbook Provides

Your configuration system acts like a comprehensive company policy manual:

1. **🏢 Company Identity** - Basic information about your API business
2. **🔐 Security Protocols** - How to handle authentication and secrets
3. **🗄️ Data Management** - Database connection and storage rules
4. **🌐 Access Control** - CORS policies for external interactions
5. **🌍 Environment Awareness** - Different rules for dev/staging/production
6. **📧 Communication Setup** - Email and notification configurations
7. **🚀 Performance Tuning** - Resource limits and optimization settings

💡 **Policy Best Practice:** Keep sensitive settings in environment variables, provide sensible defaults, and always validate configuration on startup.

⚠️ **Security Warning:** Never commit secrets like `SECRET_KEY` to version control. Use environment variables or secure secret management systems.

### 🎯 app/dependencies.py - Shared Company Resources

**🏢 Company Analogy:** Think of `dependencies.py` as your company's shared resource center. Just like a company might have shared services (HR for employee verification, IT for database access, Security for access control), FastAPI dependencies provide shared functionality that multiple departments (endpoints) can use.

```mermaid
graph TB
    A[🎯 dependencies.py<br/>🏢 Shared Resources] --> B[🔐 Authentication<br/>👮 Security Guard]
    A --> C[🗄️ Database Access<br/>📚 Librarian]
    A --> D[👤 User Verification<br/>🔍 HR Department]
    A --> E[🛡️ Authorization<br/>👨‍💼 Access Control]
    
    B --> F[🎫 Token Validation<br/>🔍 ID Checking]
    C --> G[💾 DB Sessions<br/>📖 File Access]
    D --> H[👥 Current User<br/>🆔 Employee Lookup]
    E --> I[👑 Admin Check<br/>🎖️ Permission Level]
    
    style A fill:#e3f2fd
    style B fill:#ffebee
    style D fill:#e8f5e8
```

### 🔧 Enhanced Dependencies Code

```python
# Import FastAPI dependency injection components
# Like importing the company's shared service management system
from fastapi import Depends, HTTPException, status, Request
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from typing import Optional, Generator
import logging
from datetime import datetime

# Import your company's core services
from app.utils.database import get_db
from app.utils.security import verify_token, decode_token
from app.models.user import User
from app.config import settings

# Set up logging - like company communication system
logger = logging.getLogger(__name__)

# Initialize security system - like setting up the main security checkpoint
security = HTTPBearer(
    bearerFormat="JWT",  # Specify the token format
    description="JWT Bearer token for authentication"
)

class AuthenticationService:
    """
    Authentication Service - Like your company's security department.
    
    Handles all authentication-related operations in a centralized way.
    This keeps security logic consistent across your entire application.
    """
    
    @staticmethod
    async def get_current_user(
        credentials: HTTPAuthorizationCredentials = Depends(security),
        db: Session = Depends(get_db)
    ) -> User:
        """
        Get current authenticated user - like checking employee badge at security.
        
        Args:
            credentials: The bearer token from the request header
            db: Database session for user lookup
            
        Returns:
            User: The authenticated user object
            
        Raises:
            HTTPException: If token is invalid or user not found
        """
        try:
            # Extract the token - like reading the employee badge
            token = credentials.credentials
            logger.debug(f"🔍 Verifying token for authentication")
            
            # Verify the token and get user ID - like validating the badge
            payload = decode_token(token)
            user_id: int = payload.get("sub")
            
            if user_id is None:
                logger.warning("🚫 Token missing user ID (sub claim)")
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid authentication credentials - missing user ID",
                    headers={"WWW-Authenticate": "Bearer"},
                )
            
            # Look up the user in company records - like checking employee database
            user = db.query(User).filter(User.id == user_id).first()
            if user is None:
                logger.warning(f"🚫 User {user_id} not found in database")
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="User not found",
                    headers={"WWW-Authenticate": "Bearer"},
                )
            
            # Check if user is still active - like checking if employee is still employed
            if not user.is_active:
                logger.warning(f"🚫 User {user_id} account is deactivated")
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="User account is deactivated",
                    headers={"WWW-Authenticate": "Bearer"},
                )
            
            logger.debug(f"✅ User {user.username} successfully authenticated")
            return user
            
        except HTTPException:
            # Re-raise HTTP exceptions as-is
            raise
        except Exception as e:
            # Log unexpected errors and raise a generic authentication error
            logger.error(f"❌ Authentication error: {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Authentication failed",
                headers={"WWW-Authenticate": "Bearer"},
            )

    @staticmethod
    def get_admin_user(current_user: User = Depends(get_current_user)) -> User:
        """
        Ensure current user has admin privileges - like checking manager credentials.
        
        Args:
            current_user: The authenticated user (from get_current_user)
            
        Returns:
            User: The admin user object
            
        Raises:
            HTTPException: If user doesn't have admin privileges
        """
        if not current_user.is_admin:
            logger.warning(f"🚫 User {current_user.username} attempted admin action without privileges")
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Insufficient privileges - admin access required",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        logger.debug(f"✅ Admin user {current_user.username} authorized")
        return current_user

    @staticmethod
    def get_optional_user(
        db: Session = Depends(get_db),
        credentials: Optional[HTTPAuthorizationCredentials] = Depends(security)
    ) -> Optional[User]:
        """
        Get user if authenticated, None otherwise - like checking for optional employee badge.
        
        Useful for endpoints that work for both authenticated and anonymous users.
        """
        if credentials is None:
            return None
            
        try:
            # Try to get user, but don't fail if authentication fails
            token = credentials.credentials
            payload = decode_token(token)
            user_id: int = payload.get("sub")
            
            if user_id:
                user = db.query(User).filter(User.id == user_id, User.is_active == True).first()
                return user
        except Exception as e:
            logger.debug(f"Optional authentication failed: {e}")
            
        return None

# Create dependency instances - like assigning specific security personnel
get_current_user = AuthenticationService.get_current_user
get_admin_user = AuthenticationService.get_admin_user
get_optional_user = AuthenticationService.get_optional_user

# Additional utility dependencies
def get_pagination_params(
    skip: int = 0,
    limit: int = 100
) -> dict:
    """
    Pagination parameters - like setting how many records to show per page.
    
    Args:
        skip: Number of records to skip (offset)
        limit: Maximum number of records to return
        
    Returns:
        dict: Pagination parameters with validation
    """
    # Validate pagination parameters - like checking reasonable page sizes
    if skip < 0:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Skip parameter must be non-negative"
        )
    
    if limit <= 0 or limit > 1000:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Limit must be between 1 and 1000"
        )
    
    return {"skip": skip, "limit": limit}

def get_request_id(request: Request) -> str:
    """
    Generate unique request ID - like giving each visitor a tracking number.
    
    Useful for logging and debugging to trace requests through your system.
    """
    # Check if request already has an ID (from middleware)
    request_id = getattr(request.state, "request_id", None)
    if request_id:
        return request_id
    
    # Generate a new request ID
    import uuid
    request_id = str(uuid.uuid4())[:8]
    request.state.request_id = request_id
    return request_id

# Rate limiting dependency
class RateLimiter:
    """
    Rate limiting service - like controlling how often visitors can access services.
    
    Prevents abuse and ensures fair resource usage across all users.
    """
    
    def __init__(self, calls: int, period: int):
        """
        Initialize rate limiter.
        
        Args:
            calls: Maximum number of calls allowed
            period: Time period in seconds
        """
        self.calls = calls
        self.period = period
        # In production, use Redis or similar for distributed rate limiting
        self._calls_storage = {}
    
    def __call__(self, request: Request) -> bool:
        """
        Check if request is within rate limits.
        
        Returns:
            bool: True if request is allowed
            
        Raises:
            HTTPException: If rate limit exceeded
        """
        # Get client identifier (IP address or user ID)
        client_id = request.client.host
        current_time = datetime.utcnow().timestamp()
        
        # Clean old entries
        if client_id in self._calls_storage:
            self._calls_storage[client_id] = [
                call_time for call_time in self._calls_storage[client_id]
                if current_time - call_time < self.period
            ]
        else:
            self._calls_storage[client_id] = []
        
        # Check if limit exceeded
        if len(self._calls_storage[client_id]) >= self.calls:
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail=f"Rate limit exceeded: {self.calls} requests per {self.period} seconds",
                headers={"Retry-After": str(self.period)}
            )
        
        # Record this request
        self._calls_storage[client_id].append(current_time)
        return True

# Create rate limiter instances for different endpoints
api_rate_limiter = RateLimiter(calls=100, period=60)  # 100 requests per minute
strict_rate_limiter = RateLimiter(calls=10, period=60)  # 10 requests per minute for sensitive operations
```

### ✅ What This Resource Center Provides

Your dependencies system acts like a well-organized company resource center:

1. **🔐 Security Services** - Centralized authentication and authorization
2. **🗄️ Database Access** - Consistent database session management  
3. **👤 User Management** - User lookup and verification services
4. **🎯 Parameter Validation** - Common input validation (pagination, etc.)
5. **🔍 Request Tracking** - Unique request IDs for debugging
6. **🚦 Rate Limiting** - Traffic control to prevent abuse
7. **🛡️ Permission Checking** - Role-based access control

💡 **Resource Best Practice:** Dependencies should be pure functions that are easy to test and compose. Think of them as reliable company services that other departments can always count on.

🎯 **Dependency Injection Wisdom:** FastAPI's dependency system is like having a smart assistant that automatically provides the right resources to each endpoint, handling all the setup and teardown automatically.

## 🗄️ Models Layer - Your Company's Filing System

**🏢 Company Analogy:** Think of the Models layer as your company's official filing system and record templates. Just like a company needs standardized forms for employee records, product catalogs, and customer information, your FastAPI application needs database models that define the structure and rules for storing data.

```mermaid
graph TD
    A[🗄️ Models Layer<br/>📁 Company Filing System] --> B[👤 User Model<br/>📋 Employee Records]
    A --> C[📦 Product Model<br/>📊 Inventory Records]
    A --> D[🔗 Relationships<br/>📎 Cross-References]
    
    B --> B1[🆔 Primary Keys<br/>🏷️ Employee ID]
    B --> B2[🔍 Indexes<br/>🗂️ Quick Lookup]
    B --> B3[✅ Constraints<br/>📏 Data Rules]
    
    C --> C1[💰 Financial Data<br/>💵 Pricing Info]
    C --> C2[📝 Descriptions<br/>📄 Product Details]
    C --> C3[👤 Ownership<br/>🔗 Assigned To]
    
    style A fill:#e3f2fd
    style B fill:#e8f5e8
    style C fill:#fff3e0
```

### 🗂️ app/models/user.py - Employee Records Template

**🏢 Record Analogy:** This is like designing the standard employee record form that HR uses. Every employee needs the same basic information, stored in the same format, with the same validation rules.

```python
# Import SQLAlchemy components for database modeling
# Like importing the company's official record-keeping system
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from typing import TYPE_CHECKING
import bcrypt

# Import the base class for all models
from app.utils.database import Base

# Avoid circular imports while maintaining type hints
if TYPE_CHECKING:
    from app.models.product import Product

class User(Base):
    """
    User Model - Employee Record Template
    
    This represents the official structure for storing user/employee
    information in your company's database. Like a standardized
    HR form that ensures all employee records have the same format.
    
    Attributes:
        id: Unique employee identification number
        email: Company email address (must be unique)
        username: Display name/handle (must be unique)
        hashed_password: Securely stored password (never store plain text!)
        full_name: Employee's full legal name
        is_active: Whether the employee account is currently active
        is_admin: Whether the employee has administrative privileges
        is_verified: Whether the email address has been verified
        bio: Optional personal/professional bio
        avatar_url: Profile picture URL
        created_at: When the record was first created (like hire date)
        updated_at: When the record was last modified
        last_login: When the employee last accessed the system
    """
    
    # Define the database table name - like labeling the filing cabinet
    __tablename__ = "users"
    
    # Primary identification - like employee ID badge number
    id = Column(
        Integer, 
        primary_key=True,    # This is the unique identifier
        index=True,          # Index for fast lookups
        comment="Unique user identifier - like employee ID"
    )
    
    # Contact and identity information - like business card details
    email = Column(
        String(255),         # Maximum length for email addresses
        unique=True,         # No two employees can have same email
        index=True,          # Index for fast email lookups
        nullable=False,      # Email is required
        comment="User's email address - must be unique across the system"
    )
    
    username = Column(
        String(50),          # Reasonable username length limit
        unique=True,         # No duplicate usernames
        index=True,          # Index for fast username lookups
        nullable=False,      # Username is required
        comment="User's unique username/handle for display"
    )
    
    full_name = Column(
        String(200),         # Full name storage
        nullable=True,       # Optional field
        comment="User's full legal name"
    )
    
    # Security information - like access credentials
    hashed_password = Column(
        String(255),         # BCrypt hashes are typically ~60 chars, but allow extra space
        nullable=False,      # Password is required
        comment="Securely hashed password - NEVER store plain text passwords!"
    )
    
    # Account status flags - like employee status indicators
    is_active = Column(
        Boolean,
        default=True,        # New accounts are active by default
        nullable=False,      # Always has a value
        comment="Whether the user account is currently active"
    )
    
    is_admin = Column(
        Boolean,
        default=False,       # Users are not admin by default
        nullable=False,      # Always has a value
        comment="Whether the user has administrative privileges"
    )
    
    is_verified = Column(
        Boolean,
        default=False,       # Email verification required
        nullable=False,      # Always has a value
        comment="Whether the user's email address has been verified"
    )
    
    # Optional profile information - like personal details on file
    bio = Column(
        Text,                # Text type for longer content
        nullable=True,       # Optional field
        comment="User's biographical information or personal description"
    )
    
    avatar_url = Column(
        String(500),         # URLs can be long
        nullable=True,       # Optional profile picture
        comment="URL to user's profile picture/avatar"
    )
    
    # Audit trail - like record-keeping timestamps
    created_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),  # Automatically set when record is created
        nullable=False,
        comment="When this user record was first created"
    )
    
    updated_at = Column(
        DateTime(timezone=True),
        onupdate=func.now(),       # Automatically updated when record changes
        nullable=True,             # Null until first update
        comment="When this user record was last modified"
    )
    
    last_login = Column(
        DateTime(timezone=True),
        nullable=True,             # Null until first login
        comment="When the user last successfully logged in"
    )
    
    # Relationships - like cross-references to other departments
    # This creates a relationship to products owned by this user
    products = relationship(
        "Product",           # Related model name
        back_populates="owner",  # The reverse relationship name
        cascade="all, delete-orphan",  # Delete products when user is deleted
        lazy="dynamic"       # Load products only when accessed
    )
    
    def __repr__(self) -> str:
        """
        String representation - like a summary line on a filing card.
        
        Returns a clean, readable representation of the user record.
        """
        return f"<User(id={self.id}, username='{self.username}', email='{self.email}')>"
    
    def __str__(self) -> str:
        """Human-readable string representation."""
        return self.username or self.email
    
    # Business logic methods - like standard procedures for this record type
    def check_password(self, plain_password: str) -> bool:
        """
        Verify password - like checking an employee's access credentials.
        
        Args:
            plain_password: The password to verify
            
        Returns:
            bool: True if password is correct, False otherwise
        """
        if not self.hashed_password:
            return False
        return bcrypt.checkpw(
            plain_password.encode('utf-8'),
            self.hashed_password.encode('utf-8')
        )
    
    def set_password(self, plain_password: str) -> None:
        """
        Set new password - like updating security credentials.
        
        Args:
            plain_password: The new password to hash and store
        """
        # Generate salt and hash the password
        salt = bcrypt.gensalt()
        self.hashed_password = bcrypt.hashpw(
            plain_password.encode('utf-8'), 
            salt
        ).decode('utf-8')
    
    def activate(self) -> None:
        """Activate user account - like reinstating an employee."""
        self.is_active = True
    
    def deactivate(self) -> None:
        """Deactivate user account - like putting employee on leave."""
        self.is_active = False
    
    def promote_to_admin(self) -> None:
        """Grant admin privileges - like promoting to management."""
        self.is_admin = True
    
    def demote_from_admin(self) -> None:
        """Remove admin privileges - like removing management role."""
        self.is_admin = False
    
    def verify_email(self) -> None:
        """Mark email as verified - like confirming contact information."""
        self.is_verified = True
    
    @property
    def is_superuser(self) -> bool:
        """Check if user is a superuser - like checking if they're C-level executive."""
        return self.is_admin and self.is_active and self.is_verified
    
    @property
    def display_name(self) -> str:
        """Get display name - like getting the name for a nameplate."""
        return self.full_name or self.username
    
    def to_dict(self, include_sensitive: bool = False) -> dict:
        """
        Convert to dictionary - like creating a summary report.
        
        Args:
            include_sensitive: Whether to include sensitive fields
            
        Returns:
            dict: User data as dictionary
        """
        data = {
            "id": self.id,
            "username": self.username,
            "email": self.email,
            "full_name": self.full_name,
            "is_active": self.is_active,
            "is_verified": self.is_verified,
            "bio": self.bio,
            "avatar_url": self.avatar_url,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
            "last_login": self.last_login,
            "display_name": self.display_name
        }
        
        if include_sensitive:
            data.update({
                "is_admin": self.is_admin,
                "is_superuser": self.is_superuser
            })
        
        return data
```

### ✅ What This Employee Record Template Provides

Your User model acts like a comprehensive employee record system:

1. **🆔 Unique Identification** - Primary key and indexed lookups
2. **📧 Contact Information** - Email and username with uniqueness constraints  
3. **🔐 Security Credentials** - Properly hashed passwords with verification methods
4. **👤 Profile Data** - Personal information and bio details
5. **🏷️ Status Tracking** - Active, admin, and verification flags
6. **⏰ Audit Trail** - Creation, modification, and login timestamps
7. **🔗 Relationships** - Connections to other business entities
8. **🛠️ Business Logic** - Built-in methods for common operations

💡 **Model Best Practice:** Include business logic methods directly in your models. This keeps related functionality together and makes your code more maintainable - like having standard procedures attached to each record type.

🔐 **Security Reminder:** Always hash passwords using proper libraries like bcrypt. Never store plain text passwords, even in development!

---

## 🏢 Level 2: Growing Company (Intermediate Structure)
*Perfect for: Mid-size applications, team projects, production systems*

As your FastAPI startup grows into a thriving company, you need more sophisticated organization. Think of this as moving from a small office to a multi-department building.

### 🏗️ Department Specialization

```mermaid
graph TD
    A[🏢 Growing FastAPI Company] --> B[📂 api/<br/>🏪 Customer-Facing]
    A --> C[📂 core/<br/>🏭 Internal Operations] 
    A --> D[📂 services/<br/>🧠 Business Logic]
    A --> E[📂 repositories/<br/>🗄️ Data Management]
    
    B --> B1[📋 v1/endpoints/<br/>🎯 Service Counters]
    C --> C1[⚙️ config/<br/>📋 Company Policies]
    C --> C2[🔐 security/<br/>👮 Security Dept]
    D --> D1[⚙️ business/<br/>🧮 Operations]
    E --> E1[🗃️ data/<br/>📊 Archives]
    
    style A fill:#e3f2fd
    style B fill:#e8f5e8
    style C fill:#fff3e0
    style D fill:#f3e5f5
```

---

## 🏙️ Level 3: Enterprise Corporation (Advanced Structure)
*Perfect for: Large applications, microservices, enterprise systems*

When your FastAPI company becomes an enterprise corporation, you need sophisticated organizational structure with clear hierarchies, specialized departments, and robust governance.

### 🏢 Enterprise Architecture Overview

```
enterprise-fastapi-corp/
├── 🏢 app/
│   ├── 🎯 api/                    # Public-facing departments
│   │   ├── 📋 api_v1/
│   │   │   ├── 🛣️ endpoints/      # Service desks
│   │   │   │   ├── 👥 users.py
│   │   │   │   ├── 📦 products.py
│   │   │   │   └── 📊 analytics.py
│   │   │   └── 🎯 api.py          # Department router
│   │   └── 🎭 deps.py             # Shared resources
│   ├── 🏭 core/                   # Corporate governance
│   │   ├── ⚙️ config.py           # Company constitution
│   │   ├── 🔐 security.py         # Security policies
│   │   ├── 📅 events.py           # Corporate events
│   │   └── 🚦 middleware/         # Corporate protocols
│   ├── 🧠 domain/                 # Business expertise
│   │   ├── 👤 users/
│   │   │   ├── 🏗️ models.py       # Data structures
│   │   │   ├── 📋 schemas.py      # Interface contracts
│   │   │   ├── ⚙️ services.py     # Business logic
│   │   │   └── 🗃️ repository.py  # Data access
│   │   └── 📦 products/
│   ├── 🔧 infrastructure/         # IT department
│   │   ├── 🗄️ database/
│   │   ├── 📧 email/
│   │   ├── 📁 storage/
│   │   └── 🔄 cache/
│   └── 🧪 tests/                  # Quality assurance
├── 🚀 deployment/                 # Operations
├── 📊 monitoring/                 # Analytics
└── 📚 docs/                       # Documentation
```

---

## 🎯 Your Learning Journey: From Startup to Enterprise

### 📈 Progressive Development Path

```mermaid
graph LR
    A[🚀 Startup<br/>Basic Structure] --> B[🏢 Growing Company<br/>Intermediate Structure]
    B --> C[🏙️ Enterprise<br/>Advanced Structure]
    
    A1[Simple Files<br/>All-in-one] --> A
    B1[Departmental<br/>Separation] --> B  
    C1[Domain-Driven<br/>Architecture] --> C
    
    A --> A2[Perfect for:<br/>Learning & MVPs]
    B --> B2[Perfect for:<br/>Production Apps]
    C --> C2[Perfect for:<br/>Large Systems]
    
    style A fill:#e8f5e8
    style B fill:#fff3e0
    style C fill:#e3f2fd
```

### 🎓 When to Graduate Between Levels

**🚀 Start with Startup Structure when:**
- Learning FastAPI fundamentals
- Building prototypes or MVPs
- Working solo or with 1-2 developers
- Creating simple applications (< 10 endpoints)

**🏢 Upgrade to Growing Company when:**
- Adding team members (3+ developers)
- Building production applications
- Need better code organization
- Managing multiple API versions

**🏙️ Advance to Enterprise when:**
- Building complex business systems
- Managing multiple teams/domains
- Implementing microservices
- Requiring advanced architecture patterns

---

## 🛠️ Architectural Best Practices: Building Your Digital Empire

### ✅ The Golden Rules of FastAPI Architecture

#### 🏗️ 1. Separation of Concerns - Department Specialization
```python
# ❌ Bad: Everything mixed together (like one person doing all jobs)
@app.post("/users")
async def create_user(user_data: dict, db: Session = Depends(get_db)):
    # Validation logic mixed with business logic mixed with data access
    if not user_data.get("email"):
        raise HTTPException(400, "Email required")
    if User.query.filter_by(email=user_data["email"]).first():
        raise HTTPException(400, "User exists")
    hashed_pw = hash_password(user_data["password"])
    user = User(email=user_data["email"], password=hashed_pw)
    db.add(user)
    db.commit()
    return user

# ✅ Good: Clear separation (like specialized departments)
@app.post("/users", response_model=UserResponse)
async def create_user(
    user_data: UserCreate,  # Schema handles validation
    user_service: UserService = Depends(get_user_service)  # Service handles business logic
):
    return await user_service.create_user(user_data)  # Clean delegation
```

#### 🔐 2. Security by Design - Like Corporate Security Protocols
```python
# ✅ Always authenticate at the entry point
@router.get("/admin/users")
async def list_users(
    current_user: User = Depends(get_admin_user),  # Security checkpoint
    db: Session = Depends(get_db)
):
    # Business logic here, security already handled
    pass
```

#### 📊 3. Configuration Management - Like Company Policies
```python
# ✅ Environment-specific settings
class Settings(BaseSettings):
    # Development defaults
    DATABASE_URL: str = "sqlite:///./dev.db"
    DEBUG: bool = True
    
    # Production overrides via environment variables
    class Config:
        env_file = ".env"

# ✅ Validation for production readiness
def validate_production_config():
    if settings.is_production and settings.DEBUG:
        raise ValueError("Cannot run production with DEBUG=True")
```

### 🚧 Common Pitfalls and How to Avoid Them

#### ❌ Pitfall 1: God Classes (The CEO Who Does Everything)
```python
# ❌ Bad: One class handling everything
class UserController:
    def create_user(self): pass
    def validate_email(self): pass  
    def send_email(self): pass
    def hash_password(self): pass
    def save_to_database(self): pass
    def generate_reports(self): pass  # This doesn't belong here!

# ✅ Good: Specialized classes with single responsibilities
class UserService:      # Handles user business logic
class EmailService:     # Handles email operations  
class AuthService:      # Handles authentication
class ReportService:    # Handles reporting
```

#### ❌ Pitfall 2: Circular Dependencies (Departments Depending on Each Other)
```python
# ❌ Bad: Models importing from services
# models/user.py
from services.user_service import UserService  # Creates circular import

# ✅ Good: Clear dependency hierarchy
# Services depend on models, not vice versa
# models/ -> schemas/ -> services/ -> routers/
```

### 🎯 Testing Strategy: Quality Assurance Department

```mermaid
graph TD
    A[🧪 Testing Strategy] --> B[🔬 Unit Tests<br/>Component Testing]
    A --> C[🔗 Integration Tests<br/>Department Cooperation]
    A --> D[🌐 E2E Tests<br/>Full Customer Journey]
    
    B --> B1[📦 Test Models<br/>Data Structure Tests]
    B --> B2[⚙️ Test Services<br/>Business Logic Tests]
    
    C --> C1[🗄️ Database Tests<br/>Data Layer Integration]
    C --> C2[🔐 API Tests<br/>Endpoint Integration]
    
    D --> D1[👤 User Workflows<br/>Complete Scenarios]
    D --> D2[🚀 Performance Tests<br/>Load & Stress Testing]
    
    style A fill:#e3f2fd
    style B fill:#e8f5e8
    style C fill:#fff3e0
    style D fill:#ffebee
```

### 🚀 Deployment Readiness Checklist

#### 📋 Pre-Launch Company Inspection
- [ ] **🔐 Security Audit**: No hardcoded secrets, proper authentication
- [ ] **⚙️ Configuration Review**: Environment-specific settings validated
- [ ] **🧪 Test Coverage**: All critical paths tested
- [ ] **📊 Monitoring Setup**: Health checks, logging, metrics
- [ ] **🗄️ Database Migrations**: Automated and tested
- [ ] **📚 Documentation**: API docs generated and reviewed
- [ ] **🚦 Error Handling**: Graceful failures and proper status codes
- [ ] **🔄 Backup Strategy**: Data recovery procedures in place

---

## 🎓 Graduation Exercises: Build Your Understanding

### 🏗️ Practice Projects by Level

#### 🚀 Startup Level Exercises
1. **Build a Simple Blog API** - Users, posts, comments
2. **Create a Task Manager** - Todo items with user authentication
3. **Design a Basic E-commerce** - Products, shopping cart, orders

#### 🏢 Growing Company Exercises  
1. **Multi-Tenant Application** - Separate data per organization
2. **API with Multiple Versions** - v1 and v2 endpoints
3. **Microservice Integration** - Multiple FastAPI services communicating

#### 🏙️ Enterprise Exercises
1. **Domain-Driven Design Implementation** - Complex business rules
2. **Event-Driven Architecture** - Async processing with queues
3. **Multi-Database Application** - Read/write separation, caching

### 💡 Pro Tips for Each Level

**🚀 Startup Wisdom:**
- Start simple, add complexity only when needed
- Focus on core functionality first
- Keep file structure flat and easy to navigate

**🏢 Growing Company Wisdom:**
- Introduce layers gradually
- Invest in proper testing infrastructure  
- Document architectural decisions

**🏙️ Enterprise Wisdom:**
- Design for team autonomy
- Implement robust monitoring and observability
- Plan for distributed system challenges

Remember: Your project structure should serve your team and business needs, not the other way around. Start simple and evolve as you grow! 🌱

## Schemas Layer - Request/Response Models

### app/schemas/user.py

```python
from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional

class UserBase(BaseModel):
    email: EmailStr
    username: str

class UserCreate(UserBase):
    password: str

class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    username: Optional[str] = None
    is_active: Optional[bool] = None

class UserResponse(UserBase):
    id: int
    is_active: bool
    is_admin: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

class UserInDB(UserResponse):
    hashed_password: str
```

### app/schemas/product.py

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class ProductBase(BaseModel):
    name: str
    description: Optional[str] = None
    price: float

class ProductCreate(ProductBase):
    pass

class ProductUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    price: Optional[float] = None
    is_available: Optional[bool] = None

class ProductResponse(ProductBase):
    id: int
    is_available: bool
    owner_id: int
    created_at: datetime
    
    class Config:
        from_attributes = True
```

## Services Layer - Business Logic

### app/services/user_service.py

```python
from sqlalchemy.orm import Session
from app.models.user import User
from app.schemas.user import UserCreate, UserUpdate
from app.utils.security import hash_password
from fastapi import HTTPException, status

class UserService:
    def __init__(self, db: Session):
        self.db = db
    
    def create_user(self, user_data: UserCreate) -> User:
        """Create a new user"""
        # Check if user already exists
        existing_user = self.db.query(User).filter(
            (User.email == user_data.email) | 
            (User.username == user_data.username)
        ).first()
        
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User with this email or username already exists"
            )
        
        # Create new user
        hashed_password = hash_password(user_data.password)
        db_user = User(
            email=user_data.email,
            username=user_data.username,
            hashed_password=hashed_password
        )
        
        self.db.add(db_user)
        self.db.commit()
        self.db.refresh(db_user)
        
        return db_user
    
    def get_user_by_id(self, user_id: int) -> User:
        """Get user by ID"""
        user = self.db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        return user
    
    def update_user(self, user_id: int, user_data: UserUpdate) -> User:
        """Update user information"""
        user = self.get_user_by_id(user_id)
        
        update_data = user_data.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(user, field, value)
        
        self.db.commit()
        self.db.refresh(user)
        
        return user
    
    def delete_user(self, user_id: int) -> bool:
        """Delete a user"""
        user = self.get_user_by_id(user_id)
        self.db.delete(user)
        self.db.commit()
        return True
```

## Routers Layer - API Endpoints

### app/routers/users.py

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from app.schemas.user import UserCreate, UserResponse, UserUpdate
from app.services.user_service import UserService
from app.utils.database import get_db
from app.dependencies import get_current_user, get_admin_user
from app.models.user import User

router = APIRouter()

@router.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(
    user_data: UserCreate,
    db: Session = Depends(get_db)
):
    """Create a new user"""
    user_service = UserService(db)
    return user_service.create_user(user_data)

@router.get("/users/me", response_model=UserResponse)
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """Get current user information"""
    return current_user

@router.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_admin_user)
):
    """Get user by ID (admin only)"""
    user_service = UserService(db)
    return user_service.get_user_by_id(user_id)

@router.put("/users/{user_id}", response_model=UserResponse)
async def update_user(
    user_id: int,
    user_data: UserUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Update user information"""
    # Users can only update their own profile unless they're admin
    if user_id != current_user.id and not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    
    user_service = UserService(db)
    return user_service.update_user(user_id, user_data)

@router.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_admin_user)
):
    """Delete a user (admin only)"""
    user_service = UserService(db)
    user_service.delete_user(user_id)
```

## Utilities Layer

### app/utils/database.py

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.config import settings

engine = create_engine(
    settings.DATABASE_URL,
    connect_args={"check_same_thread": False} if "sqlite" in settings.DATABASE_URL else {}
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    """Database dependency"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### app/utils/security.py

```python
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
from app.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash"""
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict) -> str:
    """Create a JWT access token"""
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def verify_token(token: str) -> int:
    """Verify and decode a JWT token"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: int = payload.get("sub")
        if user_id is None:
            return None
        return user_id
    except JWTError:
        return None
```

## Advanced Project Structure

For larger applications, consider this extended structure:

```
my-large-fastapi-app/
├── app/
│   ├── __init__.py
│   ├── main.py
│   ├── config.py
│   ├── dependencies.py
│   ├── core/                 # Core functionality
│   │   ├── __init__.py
│   │   ├── security.py
│   │   ├── config.py
│   │   └── events.py
│   ├── api/                  # API layer
│   │   ├── __init__.py
│   │   ├── api_v1/
│   │   │   ├── __init__.py
│   │   │   ├── api.py
│   │   │   └── endpoints/
│   │   │       ├── users.py
│   │   │       ├── products.py
│   │   │       └── orders.py
│   │   └── deps.py
│   ├── models/               # Database models
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── user.py
│   │   ├── product.py
│   │   └── order.py
│   ├── schemas/              # Pydantic schemas
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── product.py
│   │   └── order.py
│   ├── services/             # Business logic
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── user_service.py
│   │   ├── product_service.py
│   │   └── order_service.py
│   ├── repositories/         # Data access layer
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── user_repository.py
│   │   └── product_repository.py
│   ├── middleware/           # Custom middleware
│   │   ├── __init__.py
│   │   ├── logging.py
│   │   └── rate_limiting.py
│   ├── exceptions/           # Custom exceptions
│   │   ├── __init__.py
│   │   ├── base.py
│   │   └── handlers.py
│   └── utils/
│       ├── __init__.py
│       ├── database.py
│       ├── email.py
│       └── validators.py
├── tests/
│   ├── __init__.py
│   ├── conftest.py
│   ├── unit/
│   ├── integration/
│   └── e2e/
├── migrations/               # Alembic migrations
├── scripts/                  # Utility scripts
├── docs/                     # Documentation
├── docker/
├── .github/workflows/        # CI/CD
├── requirements/
│   ├── base.txt
│   ├── dev.txt
│   └── prod.txt
└── docker-compose.yml
```

## Repository Pattern Implementation

For complex applications, implement the repository pattern:

### app/repositories/base.py

```python
from typing import Generic, TypeVar, Type, List, Optional
from sqlalchemy.orm import Session
from sqlalchemy.ext.declarative import declarative_base

ModelType = TypeVar("ModelType", bound=declarative_base())

class BaseRepository(Generic[ModelType]):
    def __init__(self, model: Type[ModelType], db: Session):
        self.model = model
        self.db = db
    
    def get(self, id: int) -> Optional[ModelType]:
        return self.db.query(self.model).filter(self.model.id == id).first()
    
    def get_all(self, skip: int = 0, limit: int = 100) -> List[ModelType]:
        return self.db.query(self.model).offset(skip).limit(limit).all()
    
    def create(self, obj_in: dict) -> ModelType:
        db_obj = self.model(**obj_in)
        self.db.add(db_obj)
        self.db.commit()
        self.db.refresh(db_obj)
        return db_obj
    
    def update(self, db_obj: ModelType, obj_in: dict) -> ModelType:
        for field, value in obj_in.items():
            setattr(db_obj, field, value)
        self.db.commit()
        self.db.refresh(db_obj)
        return db_obj
    
    def delete(self, id: int) -> bool:
        obj = self.db.query(self.model).filter(self.model.id == id).first()
        if obj:
            self.db.delete(obj)
            self.db.commit()
            return True
        return False
```

## Best Practices

### ✅ Do's

1. **Consistent Naming**: Use clear, consistent naming conventions across all layers
2. **Separation of Concerns**: Keep models, schemas, services, and routers separate
3. **Dependency Injection**: Use FastAPI's dependency injection for better testability
4. **Configuration Management**: Centralize configuration with environment variables
5. **Error Handling**: Implement consistent error handling across the application

```python
# Good: Clear separation of concerns
# Router handles HTTP concerns
@router.post("/users", response_model=UserResponse)
async def create_user(user_data: UserCreate, db: Session = Depends(get_db)):
    user_service = UserService(db)  # Service handles business logic
    return user_service.create_user(user_data)

# Service handles business logic
class UserService:
    def create_user(self, user_data: UserCreate) -> User:
        # Business logic here
        return self.repository.create(user_data.dict())
```

### ❌ Don'ts

1. **Don't Mix Concerns**: Avoid putting business logic in routers or database logic in services
2. **Don't Hardcode Values**: Use configuration files for all settings
3. **Don't Ignore Testing**: Structure should support easy testing
4. **Don't Over-complicate**: Start simple and add complexity as needed

```python
# Bad: Business logic in router
@router.post("/users")
async def create_user(user_data: UserCreate, db: Session = Depends(get_db)):
    # Don't put business logic here
    if db.query(User).filter(User.email == user_data.email).first():
        raise HTTPException(status_code=400, detail="User exists")
    
    hashed_password = hash_password(user_data.password)
    user = User(email=user_data.email, hashed_password=hashed_password)
    db.add(user)
    db.commit()
    return user
```

## Environment-Specific Configuration

### .env.development

```bash
DATABASE_URL=sqlite:///./dev.db
SECRET_KEY=dev-secret-key
DEBUG=true
ENVIRONMENT=development
ALLOWED_HOSTS=["localhost", "127.0.0.1"]
```

### .env.production

```bash
DATABASE_URL=postgresql://user:password@postgres:5432/prod_db
SECRET_KEY=super-secret-production-key
DEBUG=false
ENVIRONMENT=production
ALLOWED_HOSTS=["yourdomain.com", "api.yourdomain.com"]
```

## Try It Yourself

1. **Create a basic project structure** for a task management API
2. **Implement the repository pattern** for your models
3. **Add environment-specific configuration** for development and production
4. **Organize a multi-version API** with proper folder structure
5. **Build a modular authentication system** using the service layer pattern

Practice these patterns to build maintainable, scalable FastAPI applications that can grow with your requirements while remaining organized and testable.