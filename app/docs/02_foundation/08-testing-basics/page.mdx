# 🧪 Testing Basics

Testing is fundamental to building reliable FastAPI applications. Well-tested code reduces bugs, improves confidence in deployments, and makes refactoring safer. FastAPI provides excellent testing support through integration with pytest and its built-in test client, making it easy to test your APIs comprehensively.

## Why Testing Matters

- **Quality Assurance**: Catch bugs before they reach production
- **Regression Prevention**: Ensure new changes don't break existing functionality  
- **Documentation**: Tests serve as living documentation of your API behavior
- **Refactoring Safety**: Change code with confidence knowing tests will catch issues
- **Team Confidence**: Well-tested code gives teams confidence to deploy frequently

## Testing Fundamentals

FastAPI applications can be tested at multiple levels:

1. **Unit Tests**: Test individual functions and classes in isolation
2. **Integration Tests**: Test how different components work together
3. **API Tests**: Test HTTP endpoints end-to-end
4. **Database Tests**: Test data persistence and retrieval

## Setting Up Testing Environment

### Test Dependencies

First, install testing dependencies:

```bash
pip install pytest pytest-asyncio httpx
```

### Test Configuration

Create a `conftest.py` file for shared test configuration:

```python
# tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool

from app.main import app
from app.utils.database import get_db, Base
from app.models.user import User
from app.utils.security import hash_password

# Test database setup
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={
        "check_same_thread": False,
    },
    poolclass=StaticPool,
)

TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def override_get_db():
    """Override database dependency for testing"""
    try:
        db = TestingSessionLocal()
        yield db
    finally:
        db.close()

# Override the dependency
app.dependency_overrides[get_db] = override_get_db

@pytest.fixture(scope="session")
def db_engine():
    """Create database tables for testing"""
    Base.metadata.create_all(bind=engine)
    yield engine
    Base.metadata.drop_all(bind=engine)

@pytest.fixture(scope="function")
def db_session(db_engine):
    """Create a fresh database session for each test"""
    connection = db_engine.connect()
    transaction = connection.begin()
    session = TestingSessionLocal(bind=connection)
    
    yield session
    
    session.close()
    transaction.rollback()
    connection.close()

@pytest.fixture(scope="function")
def client(db_session):
    """Create a test client"""
    with TestClient(app) as test_client:
        yield test_client

@pytest.fixture
def sample_user(db_session):
    """Create a sample user for testing"""
    user = User(
        email="test@example.com",
        username="testuser",
        hashed_password=hash_password("testpassword"),
        is_active=True
    )
    db_session.add(user)
    db_session.commit()
    db_session.refresh(user)
    return user

@pytest.fixture
def admin_user(db_session):
    """Create an admin user for testing"""
    user = User(
        email="admin@example.com",
        username="admin",
        hashed_password=hash_password("adminpassword"),
        is_active=True,
        is_admin=True
    )
    db_session.add(user)
    db_session.commit()
    db_session.refresh(user)
    return user
```

## Unit Testing

Test individual functions and services in isolation:

### Testing Service Layer

```python
# tests/test_user_service.py
import pytest
from fastapi import HTTPException
from app.services.user_service import UserService
from app.schemas.user import UserCreate, UserUpdate
from app.models.user import User

class TestUserService:
    
    def test_create_user_success(self, db_session):
        """Test successful user creation"""
        user_service = UserService(db_session)
        user_data = UserCreate(
            email="newuser@example.com",
            username="newuser",
            password="securepassword"
        )
        
        user = user_service.create_user(user_data)
        
        assert user.email == "newuser@example.com"
        assert user.username == "newuser"
        assert user.is_active is True
        assert user.is_admin is False
        assert user.id is not None
        assert user.hashed_password != "securepassword"  # Should be hashed
    
    def test_create_user_duplicate_email(self, db_session, sample_user):
        """Test user creation with duplicate email"""
        user_service = UserService(db_session)
        user_data = UserCreate(
            email="test@example.com",  # Same as sample_user
            username="differentuser",
            password="securepassword"
        )
        
        with pytest.raises(HTTPException) as exc_info:
            user_service.create_user(user_data)
        
        assert exc_info.value.status_code == 400
        assert "already exists" in exc_info.value.detail
    
    def test_get_user_by_id_success(self, db_session, sample_user):
        """Test getting user by ID"""
        user_service = UserService(db_session)
        
        user = user_service.get_user_by_id(sample_user.id)
        
        assert user.id == sample_user.id
        assert user.email == sample_user.email
    
    def test_get_user_by_id_not_found(self, db_session):
        """Test getting non-existent user"""
        user_service = UserService(db_session)
        
        with pytest.raises(HTTPException) as exc_info:
            user_service.get_user_by_id(999)
        
        assert exc_info.value.status_code == 404
        assert "not found" in exc_info.value.detail
    
    def test_update_user_success(self, db_session, sample_user):
        """Test successful user update"""
        user_service = UserService(db_session)
        update_data = UserUpdate(username="updateduser")
        
        updated_user = user_service.update_user(sample_user.id, update_data)
        
        assert updated_user.username == "updateduser"
        assert updated_user.email == sample_user.email  # Unchanged
    
    def test_delete_user_success(self, db_session, sample_user):
        """Test successful user deletion"""
        user_service = UserService(db_session)
        user_id = sample_user.id
        
        result = user_service.delete_user(user_id)
        
        assert result is True
        
        # Verify user is deleted
        with pytest.raises(HTTPException):
            user_service.get_user_by_id(user_id)
```

### Testing Utility Functions

```python
# tests/test_security.py
import pytest
from jose import jwt
from datetime import datetime, timedelta
from app.utils.security import (
    hash_password,
    verify_password,
    create_access_token,
    verify_token
)
from app.config import settings

class TestSecurity:
    
    def test_hash_password(self):
        """Test password hashing"""
        password = "testpassword"
        hashed = hash_password(password)
        
        assert hashed != password
        assert len(hashed) > len(password)
        assert hashed.startswith("$2b$")  # bcrypt hash prefix
    
    def test_verify_password_correct(self):
        """Test password verification with correct password"""
        password = "testpassword"
        hashed = hash_password(password)
        
        assert verify_password(password, hashed) is True
    
    def test_verify_password_incorrect(self):
        """Test password verification with incorrect password"""
        password = "testpassword"
        wrong_password = "wrongpassword"
        hashed = hash_password(password)
        
        assert verify_password(wrong_password, hashed) is False
    
    def test_create_access_token(self):
        """Test JWT token creation"""
        data = {"sub": "123"}
        token = create_access_token(data)
        
        assert isinstance(token, str)
        assert len(token) > 50  # JWT tokens are long
        
        # Decode and verify
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        assert payload["sub"] == "123"
        assert "exp" in payload
    
    def test_verify_token_valid(self):
        """Test token verification with valid token"""
        user_id = 123
        token = create_access_token({"sub": str(user_id)})
        
        decoded_user_id = verify_token(token)
        
        assert decoded_user_id == user_id
    
    def test_verify_token_invalid(self):
        """Test token verification with invalid token"""
        invalid_token = "invalid.token.here"
        
        result = verify_token(invalid_token)
        
        assert result is None
    
    def test_verify_token_expired(self):
        """Test token verification with expired token"""
        # Create token that expires immediately
        data = {"sub": "123", "exp": datetime.utcnow() - timedelta(minutes=1)}
        expired_token = jwt.encode(data, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
        
        result = verify_token(expired_token)
        
        assert result is None
```

## API Testing

Test your HTTP endpoints end-to-end:

### Testing User Endpoints

```python
# tests/test_users_api.py
import pytest
from fastapi import status
from app.utils.security import create_access_token

class TestUsersAPI:
    
    def test_create_user_success(self, client):
        """Test successful user creation via API"""
        user_data = {
            "email": "newapi@example.com",
            "username": "newapiuser",
            "password": "securepassword"
        }
        
        response = client.post("/api/v1/users", json=user_data)
        
        assert response.status_code == status.HTTP_201_CREATED
        data = response.json()
        assert data["email"] == user_data["email"]
        assert data["username"] == user_data["username"]
        assert "password" not in data
        assert "hashed_password" not in data
        assert data["is_active"] is True
        assert "id" in data
    
    def test_create_user_invalid_email(self, client):
        """Test user creation with invalid email"""
        user_data = {
            "email": "invalid-email",
            "username": "testuser",
            "password": "securepassword"
        }
        
        response = client.post("/api/v1/users", json=user_data)
        
        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    
    def test_create_user_missing_fields(self, client):
        """Test user creation with missing required fields"""
        user_data = {
            "email": "test@example.com"
            # Missing username and password
        }
        
        response = client.post("/api/v1/users", json=user_data)
        
        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    
    def test_get_current_user_success(self, client, sample_user):
        """Test getting current user information"""
        # Create access token for the user
        token = create_access_token({"sub": str(sample_user.id)})
        headers = {"Authorization": f"Bearer {token}"}
        
        response = client.get("/api/v1/users/me", headers=headers)
        
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data["id"] == sample_user.id
        assert data["email"] == sample_user.email
        assert data["username"] == sample_user.username
    
    def test_get_current_user_unauthorized(self, client):
        """Test getting current user without authentication"""
        response = client.get("/api/v1/users/me")
        
        assert response.status_code == status.HTTP_403_FORBIDDEN
    
    def test_get_current_user_invalid_token(self, client):
        """Test getting current user with invalid token"""
        headers = {"Authorization": "Bearer invalid_token"}
        
        response = client.get("/api/v1/users/me", headers=headers)
        
        assert response.status_code == status.HTTP_403_FORBIDDEN
    
    def test_get_user_by_id_admin(self, client, admin_user, sample_user):
        """Test admin getting any user by ID"""
        token = create_access_token({"sub": str(admin_user.id)})
        headers = {"Authorization": f"Bearer {token}"}
        
        response = client.get(f"/api/v1/users/{sample_user.id}", headers=headers)
        
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data["id"] == sample_user.id
    
    def test_get_user_by_id_non_admin(self, client, sample_user):
        """Test non-admin trying to get another user by ID"""
        token = create_access_token({"sub": str(sample_user.id)})
        headers = {"Authorization": f"Bearer {token}"}
        
        # Try to get a different user (ID 999)
        response = client.get("/api/v1/users/999", headers=headers)
        
        assert response.status_code == status.HTTP_403_FORBIDDEN
    
    def test_update_user_own_profile(self, client, sample_user):
        """Test user updating their own profile"""
        token = create_access_token({"sub": str(sample_user.id)})
        headers = {"Authorization": f"Bearer {token}"}
        
        update_data = {"username": "updatedusername"}
        
        response = client.put(
            f"/api/v1/users/{sample_user.id}",
            json=update_data,
            headers=headers
        )
        
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data["username"] == "updatedusername"
    
    def test_update_other_user_non_admin(self, client, sample_user):
        """Test non-admin user trying to update another user"""
        token = create_access_token({"sub": str(sample_user.id)})
        headers = {"Authorization": f"Bearer {token}"}
        
        update_data = {"username": "hacked"}
        
        # Try to update user with ID 999
        response = client.put(
            "/api/v1/users/999",
            json=update_data,
            headers=headers
        )
        
        assert response.status_code == status.HTTP_403_FORBIDDEN
    
    def test_delete_user_admin(self, client, admin_user, sample_user):
        """Test admin deleting a user"""
        token = create_access_token({"sub": str(admin_user.id)})
        headers = {"Authorization": f"Bearer {token}"}
        
        response = client.delete(f"/api/v1/users/{sample_user.id}", headers=headers)
        
        assert response.status_code == status.HTTP_204_NO_CONTENT
```

## Integration Testing

Test how different components work together:

### Database Integration Tests

```python
# tests/test_database_integration.py
import pytest
from sqlalchemy.orm import Session
from app.models.user import User
from app.models.product import Product

class TestDatabaseIntegration:
    
    def test_user_product_relationship(self, db_session: Session):
        """Test relationship between users and products"""
        # Create user
        user = User(
            email="owner@example.com",
            username="owner",
            hashed_password="hashed_password"
        )
        db_session.add(user)
        db_session.commit()
        db_session.refresh(user)
        
        # Create products for the user
        product1 = Product(
            name="Product 1",
            description="First product",
            price=19.99,
            owner_id=user.id
        )
        product2 = Product(
            name="Product 2",
            description="Second product",
            price=29.99,
            owner_id=user.id
        )
        
        db_session.add_all([product1, product2])
        db_session.commit()
        
        # Test relationship loading
        db_session.refresh(user)
        assert len(user.products) == 2
        assert product1 in user.products
        assert product2 in user.products
        
        # Test reverse relationship
        assert product1.owner == user
        assert product2.owner == user
    
    def test_cascade_delete(self, db_session: Session):
        """Test database constraints and cascading"""
        user = User(
            email="temp@example.com",
            username="temp",
            hashed_password="hashed_password"
        )
        db_session.add(user)
        db_session.commit()
        
        product = Product(
            name="Temp Product",
            price=10.0,
            owner_id=user.id
        )
        db_session.add(product)
        db_session.commit()
        
        user_id = user.id
        product_id = product.id
        
        # Delete user
        db_session.delete(user)
        db_session.commit()
        
        # Check that product still exists but owner_id is handled appropriately
        remaining_product = db_session.query(Product).filter(Product.id == product_id).first()
        # This depends on your database constraint configuration
        # You might want the product to be deleted or have owner_id set to NULL
```

## Async Testing

Test asynchronous operations:

```python
# tests/test_async_operations.py
import pytest
import asyncio
from app.services.user_service import UserService
from app.schemas.user import UserCreate

class TestAsyncOperations:
    
    @pytest.mark.asyncio
    async def test_async_user_creation(self, db_session):
        """Test asynchronous user creation"""
        user_service = UserService(db_session)
        
        async def create_user_async(email: str, username: str):
            user_data = UserCreate(
                email=email,
                username=username,
                password="password"
            )
            return user_service.create_user(user_data)
        
        # Create multiple users concurrently
        tasks = [
            create_user_async("user1@example.com", "user1"),
            create_user_async("user2@example.com", "user2"),
            create_user_async("user3@example.com", "user3"),
        ]
        
        users = await asyncio.gather(*tasks)
        
        assert len(users) == 3
        assert all(user.id is not None for user in users)
        assert len(set(user.email for user in users)) == 3  # All unique emails
```

## Testing Best Practices

### Test Organization

```python
# tests/test_products_api.py
class TestProductsAPI:
    """Group related tests in classes for better organization"""
    
    class TestProductCreation:
        """Nested class for specific functionality"""
        
        def test_create_product_success(self, client, sample_user):
            """Test successful product creation"""
            pass
        
        def test_create_product_invalid_price(self, client, sample_user):
            """Test product creation with invalid price"""
            pass
    
    class TestProductRetrieval:
        """Tests for getting products"""
        
        def test_get_product_by_id(self, client):
            """Test getting product by ID"""
            pass
        
        def test_get_products_pagination(self, client):
            """Test product listing with pagination"""
            pass
```

### Parameterized Tests

```python
# tests/test_validation.py
import pytest

class TestValidation:
    
    @pytest.mark.parametrize("email,expected", [
        ("valid@example.com", True),
        ("invalid.email", False),
        ("", False),
        ("test@", False),
        ("@example.com", False),
    ])
    def test_email_validation(self, email, expected):
        """Test email validation with various inputs"""
        from app.schemas.user import UserCreate
        
        if expected:
            # Should not raise validation error
            user = UserCreate(email=email, username="test", password="pass")
            assert user.email == email
        else:
            # Should raise validation error
            with pytest.raises(ValueError):
                UserCreate(email=email, username="test", password="pass")
    
    @pytest.mark.parametrize("price,should_pass", [
        (0.01, True),
        (999.99, True),
        (0, False),
        (-1, False),
        (-999.99, False),
    ])
    def test_price_validation(self, price, should_pass):
        """Test price validation with various inputs"""
        from app.schemas.product import ProductCreate
        
        if should_pass:
            product = ProductCreate(name="Test", price=price)
            assert product.price == price
        else:
            with pytest.raises(ValueError):
                ProductCreate(name="Test", price=price)
```

### Testing Error Scenarios

```python
# tests/test_error_handling.py
import pytest
from unittest.mock import patch, MagicMock
from sqlalchemy.exc import SQLAlchemyError
from app.services.user_service import UserService

class TestErrorHandling:
    
    def test_database_connection_error(self, db_session):
        """Test handling of database connection errors"""
        user_service = UserService(db_session)
        
        # Mock database session to raise an error
        with patch.object(db_session, 'commit', side_effect=SQLAlchemyError("Connection lost")):
            from app.schemas.user import UserCreate
            
            user_data = UserCreate(
                email="test@example.com",
                username="test",
                password="password"
            )
            
            with pytest.raises(SQLAlchemyError):
                user_service.create_user(user_data)
    
    def test_external_service_timeout(self, client):
        """Test handling of external service timeouts"""
        # Mock an external service call
        with patch('app.services.email_service.send_email', side_effect=TimeoutError("Service timeout")):
            response = client.post("/api/v1/users", json={
                "email": "test@example.com",
                "username": "test",
                "password": "password"
            })
            
            # Should still create user but handle email failure gracefully
            assert response.status_code in [201, 202]  # Depending on your error handling
```

## Test Coverage and Reporting

### Measuring Test Coverage

```bash
# Install coverage tools
pip install pytest-cov

# Run tests with coverage
pytest --cov=app --cov-report=html --cov-report=term-missing

# Generate coverage reports
coverage html
coverage report
```

### Coverage Configuration

Create a `.coveragerc` file:

```ini
[run]
source = app
omit = 
    app/tests/*
    app/venv/*
    app/__init__.py
    */migrations/*

[report]
exclude_lines =
    pragma: no cover
    def __repr__
    raise AssertionError
    raise NotImplementedError
```

## Testing Commands and Scripts

### Makefile for Testing

```makefile
# Makefile
.PHONY: test test-unit test-integration test-cov

test:
	pytest

test-unit:
	pytest tests/unit/

test-integration:
	pytest tests/integration/

test-cov:
	pytest --cov=app --cov-report=html --cov-report=term-missing

test-watch:
	pytest-watch

lint:
	flake8 app tests
	black --check app tests
	isort --check-only app tests

format:
	black app tests
	isort app tests
```

## Best Practices Summary

### ✅ Do's

1. **Test Early and Often**: Write tests as you develop features
2. **Use Descriptive Names**: Test names should describe what is being tested
3. **Test Edge Cases**: Include boundary conditions and error scenarios
4. **Keep Tests Independent**: Each test should be able to run in isolation
5. **Use Fixtures**: Leverage pytest fixtures for common setup

```python
# Good: Descriptive test name and clear assertions
def test_create_user_with_duplicate_email_raises_400_error(self, client, sample_user):
    """Test that creating a user with duplicate email returns 400 status code"""
    response = client.post("/api/v1/users", json={
        "email": sample_user.email,  # Duplicate email
        "username": "different",
        "password": "password"
    })
    
    assert response.status_code == 400
    assert "already exists" in response.json()["detail"]
```

### ❌ Don'ts

1. **Don't Test Implementation Details**: Test behavior, not internal structure
2. **Don't Write Flaky Tests**: Avoid tests that sometimes pass and sometimes fail
3. **Don't Ignore Test Failures**: Fix failing tests immediately
4. **Don't Skip Testing Error Cases**: Error paths are just as important as happy paths

```python
# Bad: Testing implementation details
def test_user_service_calls_repository_create_method(self, db_session):
    """This test is too tightly coupled to implementation"""
    user_service = UserService(db_session)
    
    with patch.object(user_service.repository, 'create') as mock_create:
        user_service.create_user(user_data)
        mock_create.assert_called_once()  # Testing internal calls, not behavior
```

## Try It Yourself

1. **Write unit tests** for a service class with create, read, update, delete operations
2. **Create API tests** for all endpoints with both success and error scenarios
3. **Implement integration tests** that test database relationships
4. **Add parameterized tests** for validation logic with multiple test cases
5. **Set up test coverage reporting** and aim for >90% coverage

Practice these testing patterns to build robust, reliable FastAPI applications that you can deploy with confidence.