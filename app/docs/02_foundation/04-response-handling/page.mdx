# Response Handling

Effective response handling is crucial for creating APIs that are secure, consistent, and easy to use. FastAPI provides powerful tools to control exactly what data your API returns and how it's formatted.

## Why Response Models Matter

1. **Security**: Prevent sensitive data leakage (passwords, internal IDs, etc.)
2. **Consistency**: Ensure all endpoints return predictable data structures
3. **Documentation**: Response models appear in auto-generated API docs
4. **Performance**: Exclude unnecessary fields to reduce payload size
5. **Versioning**: Manage API evolution by controlling response formats

## Basic Response Models

### Filtering Sensitive Data

The most common use case is preventing sensitive information from being exposed:

```python
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime

app = FastAPI()

# Input model - includes sensitive data
class UserCreate(BaseModel):
    username: str
    email: EmailStr
    password: str
    full_name: Optional[str] = None
    is_admin: bool = False

# Database model - what we store
class UserInDB(BaseModel):
    id: int
    username: str
    email: EmailStr
    hashed_password: str
    full_name: Optional[str]
    is_admin: bool
    created_at: datetime
    last_login: Optional[datetime]

# Response model - what we return
class UserResponse(BaseModel):
    id: int
    username: str
    email: EmailStr
    full_name: Optional[str]
    created_at: datetime

@app.post("/users", response_model=UserResponse, status_code=201)
async def create_user(user: UserCreate):
    # Hash password (simplified for example)
    hashed_password = f"hashed_{user.password}"
    
    # Create user in DB
    db_user = UserInDB(
        id=12345,
        username=user.username,
        email=user.email,
        hashed_password=hashed_password,
        full_name=user.full_name,
        is_admin=user.is_admin,
        created_at=datetime.utcnow(),
        last_login=None
    )
    
    # Return db_user - FastAPI will filter based on UserResponse
    return db_user
```

## Advanced Response Patterns

### Multiple Response Models

Different endpoints might need different views of the same data:

```python
# Public view of a user
class UserPublic(BaseModel):
    username: str
    full_name: Optional[str]

# Detailed view for the user themselves
class UserPrivate(BaseModel):
    id: int
    username: str
    email: EmailStr
    full_name: Optional[str]
    created_at: datetime
    email_verified: bool
    profile_complete: bool

# Admin view with all details
class UserAdmin(BaseModel):
    id: int
    username: str
    email: EmailStr
    full_name: Optional[str]
    is_admin: bool
    created_at: datetime
    last_login: Optional[datetime]
    account_status: str
    failed_login_attempts: int

@app.get("/users/{username}", response_model=UserPublic)
async def get_user_public(username: str):
    # Return public information only
    return get_user_from_db(username)

@app.get("/users/me", response_model=UserPrivate)
async def get_current_user(current_user: User = Depends(get_current_user)):
    # Return private information for authenticated user
    return current_user

@app.get("/admin/users/{user_id}", response_model=UserAdmin)
async def get_user_admin(user_id: int, admin: User = Depends(require_admin)):
    # Return full information for admins
    return get_user_from_db(user_id)
```

### Generic Response Wrappers

Create consistent response formats across your API:

```python
from typing import TypeVar, Generic, Optional, List
from pydantic.generics import GenericModel

T = TypeVar('T')

class ResponseModel(GenericModel, Generic[T]):
    data: T
    message: str = "Success"
    status_code: int = 200
    timestamp: datetime = Field(default_factory=datetime.utcnow)

class PaginatedResponse(GenericModel, Generic[T]):
    items: List[T]
    total: int
    page: int
    size: int
    pages: int
    has_next: bool
    has_prev: bool

# Usage
@app.get("/users", response_model=ResponseModel[List[UserResponse]])
async def list_users():
    users = get_all_users()
    return ResponseModel(
        data=users,
        message="Users retrieved successfully"
    )

@app.get("/users/paginated", response_model=PaginatedResponse[UserResponse])
async def list_users_paginated(
    page: int = Query(1, ge=1),
    size: int = Query(10, ge=1, le=100)
):
    users, total = get_users_paginated(page, size)
    total_pages = (total + size - 1) // size
    
    return PaginatedResponse(
        items=users,
        total=total,
        page=page,
        size=size,
        pages=total_pages,
        has_next=page < total_pages,
        has_prev=page > 1
    )
```

### Response Model Configuration

Customize how response models handle data:

```python
class ProductResponse(BaseModel):
    id: int
    name: str
    price: float
    description: Optional[str]
    tags: List[str]
    
    class Config:
        # Include computed fields
        orm_mode = True
        
        # Customize field serialization
        json_encoders = {
            datetime: lambda v: v.isoformat(),
            Decimal: lambda v: float(v)
        }
        
        # Control which fields to include/exclude
        fields = {
            "price": {"description": "Price in USD", "example": 29.99}
        }

# Excluding fields dynamically
@app.get("/products/{product_id}")
async def get_product(
    product_id: int,
    include_description: bool = Query(True)
):
    product = get_product_from_db(product_id)
    
    if not include_description:
        return ProductResponse(**product.dict(exclude={"description"}))
    
    return ProductResponse.from_orm(product)
```

## Status Codes and Headers

### Setting Status Codes

```python
from fastapi import status

@app.post(
    "/items",
    response_model=ItemResponse,
    status_code=status.HTTP_201_CREATED
)
async def create_item(item: ItemCreate):
    # Create item
    return new_item

@app.delete(
    "/items/{item_id}",
    status_code=status.HTTP_204_NO_CONTENT
)
async def delete_item(item_id: int):
    # Delete item
    return  # No content for 204 response

# Dynamic status codes
@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: ItemUpdate,
    response: Response
):
    existing = get_item(item_id)
    if not existing:
        response.status_code = status.HTTP_201_CREATED
        return create_new_item(item_id, item)
    else:
        response.status_code = status.HTTP_200_OK
        return update_existing_item(item_id, item)
```

### Custom Headers

```python
from fastapi import Response

@app.get("/items")
async def list_items(
    response: Response,
    page: int = 1,
    size: int = 10
):
    items, total = get_items_paginated(page, size)
    
    # Add pagination headers
    response.headers["X-Total-Count"] = str(total)
    response.headers["X-Page"] = str(page)
    response.headers["X-Page-Size"] = str(size)
    
    # Add caching headers
    response.headers["Cache-Control"] = "public, max-age=3600"
    
    return items

# Headers in response model
class FileResponse(BaseModel):
    filename: str
    size: int
    content_type: str

@app.post("/upload")
async def upload_file(
    file: UploadFile,
    response: Response
):
    # Process file
    file_id = save_file(file)
    
    # Add location header for created resource
    response.headers["Location"] = f"/files/{file_id}"
    
    return FileResponse(
        filename=file.filename,
        size=file.size,
        content_type=file.content_type
    )
```

## Response Types

### JSON Responses (Default)

```python
@app.get("/data")
async def get_data():
    return {"key": "value"}  # Automatically serialized to JSON
```

### File Responses

```python
from fastapi.responses import FileResponse, StreamingResponse
import io

@app.get("/download/{file_id}")
async def download_file(file_id: str):
    file_path = get_file_path(file_id)
    return FileResponse(
        path=file_path,
        filename="document.pdf",
        media_type="application/pdf"
    )

@app.get("/stream")
async def stream_data():
    def generate():
        for i in range(1000):
            yield f"Line {i}\n".encode()
    
    return StreamingResponse(
        generate(),
        media_type="text/plain"
    )
```

### HTML Responses

```python
from fastapi.responses import HTMLResponse

@app.get("/page", response_class=HTMLResponse)
async def get_page():
    return """
    <html>
        <head><title>FastAPI Page</title></head>
        <body>
            <h1>Welcome to FastAPI</h1>
        </body>
    </html>
    """
```

## Error Response Models

Standardize error responses across your API:

```python
class ErrorDetail(BaseModel):
    field: Optional[str] = None
    message: str
    code: str

class ErrorResponse(BaseModel):
    error: str
    details: List[ErrorDetail] = []
    request_id: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)

@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    return JSONResponse(
        status_code=400,
        content=ErrorResponse(
            error="Validation Error",
            details=[ErrorDetail(
                message=str(exc),
                code="VALUE_ERROR"
            )],
            request_id=request.headers.get("X-Request-ID", "unknown")
        ).dict()
    )

# Using in endpoints
@app.post("/transfer", responses={
    200: {"model": TransferResponse},
    400: {"model": ErrorResponse},
    403: {"model": ErrorResponse}
})
async def transfer_money(transfer: TransferRequest):
    if not has_sufficient_balance(transfer.from_account, transfer.amount):
        return JSONResponse(
            status_code=400,
            content=ErrorResponse(
                error="Insufficient Balance",
                details=[ErrorDetail(
                    field="amount",
                    message="Account has insufficient balance for this transfer",
                    code="INSUFFICIENT_BALANCE"
                )],
                request_id=generate_request_id()
            ).dict()
        )
    
    # Process transfer
    return TransferResponse(...)
```

## Performance Optimization

### Response Model Exclusion

```python
class UserDetailed(BaseModel):
    id: int
    username: str
    email: str
    profile: dict  # Large nested data
    settings: dict  # User preferences
    activity_log: List[dict]  # Potentially large

@app.get("/users/{user_id}")
async def get_user(
    user_id: int,
    include_profile: bool = False,
    include_settings: bool = False,
    include_activity: bool = False
):
    user = get_user_from_db(user_id)
    
    exclude_fields = set()
    if not include_profile:
        exclude_fields.add("profile")
    if not include_settings:
        exclude_fields.add("settings")
    if not include_activity:
        exclude_fields.add("activity_log")
    
    return UserDetailed(**user.dict(exclude=exclude_fields))
```

### Streaming Large Responses

```python
from fastapi.responses import StreamingResponse
import json

@app.get("/large-dataset")
async def get_large_dataset():
    async def generate():
        yield b'['
        first = True
        
        async for item in fetch_large_dataset():
            if not first:
                yield b','
            yield json.dumps(item.dict()).encode()
            first = False
        
        yield b']'
    
    return StreamingResponse(
        generate(),
        media_type="application/json"
    )
```

## Best Practices

### 1. Use Specific Response Models
```python
# Bad - returns everything
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return get_user_from_db(user_id)

# Good - returns only what's needed
@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    return get_user_from_db(user_id)
```

### 2. Document Response Examples
```python
class ProductResponse(BaseModel):
    id: int
    name: str
    price: float
    
    class Config:
        schema_extra = {
            "example": {
                "id": 1,
                "name": "FastAPI Book",
                "price": 29.99
            }
        }
```

### 3. Version Response Models
```python
# v1/models.py
class UserResponseV1(BaseModel):
    id: int
    username: str
    email: str

# v2/models.py
class UserResponseV2(BaseModel):
    id: int
    username: str
    email: str
    profile_picture: Optional[str]  # New field in v2
    verified: bool = False  # New field with default
```

## Try It Yourself

Create a comprehensive response handling system:

```python
# Exercise: Build a blog API with:
# - Different response models for list vs detail views
# - Public vs authenticated user responses
# - Pagination with metadata
# - Error responses with consistent format
# - Response caching headers
# - File download endpoints for post attachments
```

In the next section, we'll explore comprehensive error handling strategies.